<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tmr&#39;s Blog</title>
    <link>https://HNUrookie1.github.io/</link>
    
    <atom:link href="https://hnurookie1.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 13 Jul 2024 14:47:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>放假反省</title>
      <link>https://hnurookie1.github.io/2024/07/13/%E6%94%BE%E5%81%87/</link>
      <guid>https://hnurookie1.github.io/2024/07/13/%E6%94%BE%E5%81%87/</guid>
      <pubDate>Sat, 13 Jul 2024 14:07:03 GMT</pubDate>
      
      <description>Here&#39;s something encrypted, password is required to continue reading.</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e1a25cea275faabdb9aa8d25860458cf8609cbf597e9716534839f830665c9f">54e3726371269f5f4d16eecc3c6bcb4294d1ceff3847bbb1c1d7111be0949bb9f104514ddc5434542afeee4f4852693891615e7a4e810e7a0c99ee305a051e97e2bfb026ce43aa1ad064f5a1d980d72e4e05ae2f8bd35f761bbf68f5e49ae0f6cd615672be48511a35bcab13e8f30836959297a0d79fb610988f66becb0269f1006cce64282c49e5778a527a633e375ccf90969df7969808a24c7620d7ad987324e9a730be5bb24e1a717f879d91451b7ff0f257497c8044452e834bd089eea1c53bd15beb0c1015daa435a43afd230756e29743f1518115998c70e7556cc5089e35992458fef1dc5e398936ed53c0fafdb3949c33d7f597b0f85f810b52b0a55246ef81c3017bd2f599ad3068dfa15a62301976c219b74ffbc8cb9782f763a25cdaf35fcb758b1e3c47a221e25c86d6c673d1f90ca67809642b3c35ccf9b4ed91a44275750b4214174b7b811ec9453729883bec1e497e3b3e895a4cb8e317b263f50c91c3107e81e4d92305cee1fd252e72efb3f1ee73fffc93247341dc0f8a86824289687ecf88e4721248d0826be749d07ccd62f5f097311c3d3c96a2ffffcf7b94659a5375a133698fad7ea6448b391abfa9ca0167707effeafcbc2529d90fe7f391710a49ec0180896c66bb7b0f73c7184f093e0eefe621c33173402171dcf8eaef45bbcaa1395c138ab1cee75139b7e827c2352989fcd87ba703440377c08deebe0478359e0f5ec33c659eb0e24397fa1a2422b160dc13dbf59b49664008c036a5baebbc3d878fe798aae2f9d273ad592420a214e287d81fda9d763c86b62375095603a8d0a2b82807def84908a791a58de4c96b5626f3f9ea590d70cf30ebd62b076b55bd33de0e76874c974d7afe3d2c4135888f7a36eebcce04ba07d83699216df408eda85adaae8f28d35ba37c2ae9929bab2fc5099838b2d89f1a272faf47e72a25596da61ce4e1b8f96b56e0a7e3f9a12f0c7c13f27508fce5537834132272d9b12c16d8bc8bfb5fb17a4b6dfa9fd054b131c48db7d9d79eefb47c3b4f4ab04feaf8d1faebbb9cae6bdc6d42e9de3bb9ebe70e0655c0c39695a856e89b50b515b2c00379e22ded6702b180723069aabb06c4c40a267d321256b8387d7004bcef11360dd3320e2b3aca5d6047713f17a27bb503a5e376d51ae4f9b2010d91341eaa20db41eef0d8efc0b71c3139e65e6e6268bfc08503f3a8fb55b7a2dad80f12f7d91b3c0179b0740485100b18ec6484686720e7cae3c64a89d5138db29da166fc1232332cac2c7369cce06a4c6fa04e09e2f2d555b731b4620db198b285923ef0e419959a05ad3efdd766e12dbe859de953bb5d20c29e5cc596144c28fbeafef74416c0c8fa79d0a5a353eee6fbd5558fef9d38f6be6fec95def465f1fe598d622ffca8f0c3631d5eb748d74542c3c99c6474916e2da96efa09c93790fd6e9acd22572c1c7175407048bc326efa182cd717777bcec3a750eb5840a9cf3d3d9de106b5593ca681cf80df347ec67f4b22a2dea7087c76b585557744beed338cd20f49b7ce0e68d74965a40e72bdb54bb2dd0a3a60ba70fdadd2cf2a4f2a9fd9b831364d352e17f34ecec39c0c195ef1510d51bbacd4926c1811a980803bee50c7b3518e7ac024257c0728b4a9c3ac9e440f669761827e63f12bfebf4eed3868d3a309fffb6f4c34d415e6b9389164368925d701f06666dc2155dba5a416a71ca53dd3901701aea3daa09778d2d2e0b1a2ebe3995045c26c385424e90360b17559becb277ec3b1fd75fcc37698c96bc7180eb7b26f2cec8be5dd873c4d07b4415ffe825b9afa63d6450c417f4c8670db5819407f637e3e19b4061ef948627b0558428d355e40f9642affe8cb1215f8b440d570493b6de21480be16ac7625b62e30d3ea47500c39406e8603826f43846f79c1d9ca000bb302e36ff9f4ebde7248323586484a2d572990599607145134ad8225c3c3be3146583953590853ee1a4290f5eac09e9465b9cb9bc9e53eacb4032c83666d20ea893e95f34d97e6ddc630e7d1b7fe983ef357557af6b6c671fc53dce10724478b5c3556d6dadd2d578cf29b968ab29ea3223667f20a386a3376e83a7d352602543e276fdcbdc64ab331120895bcc5e722deea93e5c04e15c0ff438c6434d6d54ce21afe043b8974fd9ec1e0ebd58116c44406395030ce6c874c058a3319febd031d1122b0fefc5d257a8e020fa158416c095c9b129066504d1fd6517ee1f2f11ef1ad429a3f34f7782bb7bb4436ba244fd5f490182e943c4e349e39290a93b97e829253ee218609165bf8adc02acb521a0db14c83fb2f541424936be3558ea7c87b2ca0ba34e0039a0ddb439dd227b528d9dcff6b9f29f0cef4550d2fdc2761ea48e3f8b4540e89d02a6a86228959e4fe473a7a8a14846e230724b5b67cf85db00781d404864bd66ff52c10a88c30561c203e5b2dbb2efdfffad2b3830488af33cfdd20aa3b75e651596759cf20e7a87401437ede28340dd59603ed765a02b4eb7e0263425e0e9a22d80a5229c3b1180b9094c342c7dad1f7382dc80283d800b083b6fff1f87abcf914ce2bddaceb2f92b3bd733e3a7ddc7c8453c7062ce1ea4ef08e52a9bb4c8bd61e000498ee693bbd4cd3cfce62f0e1d8482e3c7a8f4f80757a5c3edb5a1e98dc064b9ad53f1b8d32c39e2b93d6548d818cebdc182c0c7e0eaae6ead1851fd4bcf28685300d153088a89689c7fcd4c9422a5b937282b42afedf658378aedf90f33a4668e1d4308b21571b25b22c529c81210c48fd9c523096f54ce723c4f8504aff331ced508779068cbf0ad1f9dc8f4c8d371e6e05fb00fdd93fa6d2d3f512223f314b256f6f56cfa4669142bb209f4a7224d50e1863c4a47ea337bc027f81b8a31fabea8df5e328566b06b56d42b426806b8a26ae53859d6c36dae5f713f071c30589156da5bf5711d5995c1ee26d8420243c63afa63d528ac1d365cd4677c13f89d221fbe3c7480186cd6737405cecdc023fc729fed4dba80306c1939dfa3fc93b30b6bb2e9d14e8a1f977c415e14fc634a56ba7f61f315aa143f7760288383a7bd6d52d21c86c088af7770176aff7f50805e6fdbe50a5a98619f7503746f2baa2f04e91a23c61ddd00fa7df33609b68a3d07b20f5a93d3f4c81d48e000c71de237c4e6133e713dc47a1dffaa9a3f4a3adee35029f7fce8a10f566b7b5301b1c885b8c5882aa718efb159497f3deec0cf68ea3d3481c5a9c913795535765c6ccc684c2c0363dc76caac049751ffd2d2fb0df1872f6f50dd375b9aad67a702cc1920fea938637fac520ba280299b52734f5e85662af67e381457913442091c02e390b017207ec502aba217e4b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      
      <category domain="https://HNUrookie1.github.io/tags/Life-Record/">Life Record</category>
      
      
      <comments>https://hnurookie1.github.io/2024/07/13/%E6%94%BE%E5%81%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>夏令营面试</title>
      <link>https://hnurookie1.github.io/2024/07/07/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</link>
      <guid>https://hnurookie1.github.io/2024/07/07/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</guid>
      <pubDate>Sun, 07 Jul 2024 02:45:39 GMT</pubDate>
      
      <description>Here&#39;s something encrypted, password is required to continue reading.</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="951aaaeb503ab223966faf29b4a0a832d10646c276deb96940389b37a8d915d6">54e3726371269f5f4d16eecc3c6bcb42d185cacc6501b297ebb531def94b648a782469698b7eee9c4be4e8b63bc00fb0dd092588a7bc62532298e4ad870aae4b1fa7bde180b9f2fec2c70e58a56d8b0a8361919c35db03bdd4a4c5e3525db718ca00839ae692b722fa90c1ef8748526a3e2ffad3fec764b2854c4660dbf35007c7d7e292a9e403fca3c4b7fbcb69d27493f53844f753f94714bed5cdab07febc71150733369d3a5a3b16562185f93c3359f47ac5c7ef21164b00aafc520a16e42b2d648219f7757e9fb22716cf42b6f6739262c084c98ca974aabc84f30c25d2fdc0659ac5579776ec90c6ac8d8b43ad93c27eb2936f84b4b63779b65cfac5959100e3bb443e94c3e7067720cd5554406ffff5cea597a437adc41239064d0bbd75bab5f498fd4249725405efeb7e8999c42281eef3616c5d7c8d9a5fd097937e371d18b66d4d9dfccc88df8aa9121f67cb2e39423b59c471b961cef54cb6cc7d00c25a60993378765a0c77c8db51fa36e8d6d8d7d9e8ffe66e6d32634ec3812ca3e81cc5a1390bbb17d7e5e6d7341fcc1ead6f3d5fec8bc2970fa1c7039252f3047f69a1724965e9bf7f3425a539a6b9d8528d451eb07c1cd3aba4bb9c2c58012113a9e7ff0476edd7d2c79d3b87a782729507ce5e5a826c9c7d3950aa07c05301bdb4751150496d6c383b356df4b9e0acea240169c200dce0c207198664743a9c59a60f15bf77bb3723f3fbf3fbd1f2842a83026fea9967616cd6631778178274a962a120383443dc3d77c3463ca4a6dadfd28e9714922df3492ee83f825c397d4b3a60a170dcc061db649623852d7650323dd6af38a5542300e86e51d2fca77a8bf101af099bee0eaa63a648c195e363ca1540250d7c9f004bad03fd79576f148faa22b1b86f0759248dd53b5037fe6c4e85514c2838b99e9e4d36f7aca3fbdebeb5fef78584e78501dac8bffd866f55acd9d453fcd49e9954987393243ddfb52a7d4d3e6cf0dd2dc1db995c2bff97c69ea1d7e21fff96371f8a04a06110ba8b7dd1ea643aef02afaebfb06fcc76d4fa2c84563bc0177a3bf76a4e8dfe7b5869adc9c19c48cbd76f169ac3579394a4acb3b7cd6dae140e142e34238b358db809a2b47167b79e637b426874c0899e686faef4fb5a0a72b2401397844b60c3255086ee851328df58e2a4252e7106b31ef034ca1531e42765f703203965dfddad9b4c01292eea5fe569830d989d14e45d945e4bbf3012abce8afed2ca6d2ae32be708d49d3f159ae3cce64ced342e8510ae0e58babd9e121775c0230e51d27ec5876dd9e5f00bf257dafde600353dc92e3af608d7f063a93202db06cd8437849f07d0a2f6f7b680003c627619ee5d2567c69bb458ead14465c79cea0a3648da4de9cd83acc67b891ebe29745167a6cda61abce21ea55d76ec88f35567ae6a62e1ccaacae3c6f9bd3d8541866034ec82727459b0ed1e185266fb95a96a3a25498e80a730e75c5c3bf01109a02897228a94af8c2acd77df00043c32a7580a95aa9384abc162f2e5dd645bf7c4f5ef3da1f5828a331af4d73c153130902d2a39e1197584851234959d47a5af31b04b30bf1a60da81e3c73109769970dc117b2ffe43347f330ce28ef0a159ec7744536b110750ae79a0177943435261cb780ddd332e9c85f8cf5ce333d563489d13143cb6691d441688740f25ac718bb9099aa8f2850aa9b13ab9582c42f75d273503753b377b922bb197aedee5347cd001ae707ed8a7e26ae8f416edd12c077169743ca4d24c1f9f67231e51e9d64d6d861e2f44ae5a6047ac8f25f8390a0a1ba0937e21fe5e01c9227ab3591c08bb8e99ff2952bbbae7c46ce844313f8c1c9d08950719b8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      
      <category domain="https://HNUrookie1.github.io/tags/Life-Record/">Life Record</category>
      
      
      <comments>https://hnurookie1.github.io/2024/07/07/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PGP实现</title>
      <link>https://hnurookie1.github.io/2024/06/30/PGP%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://hnurookie1.github.io/2024/06/30/PGP%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 30 Jun 2024 10:57:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;请转至&lt;a href=&quot;http://t.csdnimg.cn/gLlHS&quot;&gt;http://t.csdnimg.cn/gLlHS&lt;/a&gt; ！&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>请转至<a href="http://t.csdnimg.cn/gLlHS">http://t.csdnimg.cn/gLlHS</a> ！</p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/cryptography/">cryptography</category>
      
      
      <category domain="https://HNUrookie1.github.io/tags/cryptography/">cryptography</category>
      
      
      <comments>https://hnurookie1.github.io/2024/06/30/PGP%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计网学习笔记</title>
      <link>https://hnurookie1.github.io/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://hnurookie1.github.io/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 28 Jun 2024 09:05:41 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h1&gt;&lt;h2 id=&quot;拥塞控制&quot;&gt;&lt;a href=&quot;#拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;拥塞控制&quot;&gt;&lt;/a&gt;拥塞控</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ul><li>在某段时间，若对网络中某一资源的需要超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况叫做拥塞（congestion）。<ul><li>在计算机网络中的链路容量（即带宽）、交换节点中的缓存和处理机等，都是网络的资源。</li></ul></li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随负荷的增大而下降。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/1.png"></li><li>TCP的四种拥塞控制算法：慢开始（slow start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）。</li></ul><h3 id="慢开始、拥塞避免"><a href="#慢开始、拥塞避免" class="headerlink" title="慢开始、拥塞避免"></a>慢开始、拥塞避免</h3><p><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/2.png"></p><ul><li>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值<strong>取决于网络的拥塞程度</strong>，并且<strong>动态变化</strong>。<ul><li>拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就在增大一些；但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生重传）。</li></ul></li><li>发送方将拥塞窗口作为发送窗口，即<strong>swnd &#x3D; cwnd</strong>。</li><li>维护一个慢开始门限<strong>ssthresh</strong>的状态变量：<ul><li>当cwnd &lt; ssthresh时，<strong>使用慢开始算法，每收到一个报文段的确认cwnd加1</strong>；</li><li>当cwnd &gt; ssthtesh时，停止使用慢开始算法而<strong>改用拥塞避免算法，每经过一个往返时延cwnd加1；</strong></li><li>当cwnd &#x3D; ssthres时，既可以使用慢开始算法，也可以使用拥塞避免算法。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/3.png"></li></ul></li><li>“慢开始”是指一开始向网络中注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；</li><li>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ul><li>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法（TCP Tahoe版本）。</li><li>1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复（TCP Reno版本）。<ul><li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。<ul><li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li><li>发送方错误地启动慢开始算法，并把拥塞窗口cwnd又设置为最小值1，因而降低了传输效率。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/4.png"></li></ul></li></ul></li><li>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</li><li>所谓快重传，就是使发送方尽快进行重传，而不是等待重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>；</li><li>即使收到了失序（不是按照顺序来的）报文段也要立即发出对已收到报文段的<strong>重复确认</strong>；</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段<strong>立即重传</strong>，而是不是等到该报文段的超时重传计时器超时在重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使得整个网络的吞吐量提高约20%。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/5.png"></li></ul></li></ul><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><ul><li>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而是<strong>执行快恢复算法</strong>。令ssthresh &#x3D; cwnd &#x3D; cwnd&#x2F;2。</li><li>也有的快恢复实现是把恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3；<ul><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li><li>可见现在网络中你不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/6.png"></li></ul></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://HNUrookie1.github.io/tags/Computer-Network/">Computer Network</category>
      
      
      <comments>https://hnurookie1.github.io/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git学习笔记</title>
      <link>https://hnurookie1.github.io/2024/05/22/Git%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://hnurookie1.github.io/2024/05/22/Git%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 21 May 2024 16:18:35 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Git分支-分支简介-2024-5-24&quot;&gt;&lt;a href=&quot;#Git分支-分支简介-2024-5-24&quot; class=&quot;headerlink&quot; title=&quot;Git分支-分支简介(2024-5-24)&quot;&gt;&lt;/a&gt;Git分支-分支简介(2024-5-24)&lt;/h1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Git分支-分支简介-2024-5-24"><a href="#Git分支-分支简介-2024-5-24" class="headerlink" title="Git分支-分支简介(2024-5-24)"></a>Git分支-分支简介(2024-5-24)</h1><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程–常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。<br>有人把Git的分支模型称为它的“必杀技特性”，也正因为这一特性，使得Git从众多版本控制系统中脱颖而出。为何Git的分支模型如此出众呢？Git处理分支的方式可谓是难以执行的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其他版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>为了真正理解Git处理分支的方式，我们需要回顾以下Git是如何保存数据的。<br>Git保存的不是文件的变化或者差异，而是一系列不同时刻的快照。<br>在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以很自然的想到–该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象还没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。<br>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和（使用SHA-1哈希算法），然后会把当前版本的文件快照保存到Git仓库中（Git使用blob对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &quot;The initial commit of my project&quot;</span><br></pre></td></tr></table></figure><p>当使用<code>git commit</code>进行提交操作时，Git会先计算每一个子目录（本目录中只有项目根目录）的校验和，然后在Git仓库中将这些校验和保存为树对象。</p><h1 id="Git分支-远程分支-2024-5-22"><a href="#Git分支-远程分支-2024-5-22" class="headerlink" title="Git分支-远程分支(2024-5-22)"></a>Git分支-远程分支(2024-5-22)</h1><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用时对远程仓库的引用（指针），包括分支、标签等等。你可以通过 <code>git ls-remote &lt;remote&gt;</code>来显示地获取远程引用的完整列表，或者通过<code>git remote show &lt;remote&gt;</code>来获取远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。<br>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信，Git就会为你移动它们以精确反应远程仓库的状态。请将它们看做书签，这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。<del>休息，明天再写</del><br><strong>（2024-5-23）</strong><br>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名。例如，如果你想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态，你可以查看<code>&lt;origin&gt;/&lt;branch&gt;</code>分支。你与同是合作解决一个问题并且她们推送了一个<code>iss53</code>分支，你可能有自己的本地<code>iss53</code>分支，然而在服务器上的分支会以<code>origin/iss53</code>来表示。<br>这可能有一点难以理解，让我们来看一个例子。假如你的网络里有一个在<code>git.ourcompany.com</code>的Git服务器。如果你从这里克隆，Git的<code>clone</code>命令会为你自动将其命名为<code>ogigin</code>，拉去它的所有数据，创建一个指向它的<code>master</code>分支，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与origin的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。<br><strong>Note</strong>:<br>“origin” 并无特殊含义<br>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/1.png"><br>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/2.png"><br>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/3.png"><br>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add teamone git://git.team1.ourcompany.com</code> 命令添加一个新的远程仓库引用到当前的项目，将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/4.png"><br>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/5.png"></p><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>， 那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支。” 你也可以运行 <code>git push origin serverfix:serverfix</code>， 它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。<br><strong>Note</strong><br><em>如何避免每次输入密码?</em><br>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure><p>现在，本地分支  <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:<br>具体来说，<code>git branch -u</code>（或 <code>--set-upstream-to</code>）命令用于将本地分支配置为跟踪一个特定的远程分支。这样，你在进行操作时（例如拉取或推送），Git 知道应该与哪个远程分支进行交互。  </p><p>举个例子：命令 $ <code>git branch -u origin/serverfix</code> 的含义如下：<br>该命令将本地 serverfix 分支设置为跟踪远程仓库 origin 上的 serverfix 分支。当你在 <code>serverfix</code> 分支上运行 <code>git pull</code> 或 <code>git push</code> 时，不需要再指定远程分支，Git 会默认与 <code>origin/serverfix</code> 进行交互。</p><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的<code> server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<br><code>$ git fetch --all; git branch -vv</code></p><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 <strong>如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</strong></p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。(完)</p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Necessary-Tools/">Necessary Tools</category>
      
      
      <category domain="https://HNUrookie1.github.io/tags/Git/">Git</category>
      
      
      <comments>https://hnurookie1.github.io/2024/05/22/Git%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GNU Make学习笔记</title>
      <link>https://hnurookie1.github.io/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://hnurookie1.github.io/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Sat, 18 May 2024 16:55:28 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Makefile介绍&quot;&gt;&lt;a href=&quot;#Makefile介绍&quot; class=&quot;headerlink&quot; title=&quot;Makefile介绍&quot;&gt;&lt;/a&gt;Makefile介绍&lt;/h1&gt;&lt;p&gt;make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明Makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p><ol><li><p>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</p></li><li><p>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</p></li><li><p>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</p></li></ol><p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p><h1 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h1><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    recipe</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>target</strong><br>可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p><p><strong>prerequisites</strong><br>生成该target所依赖的文件和&#x2F;或target。</p><p><strong>recipe</strong><br>该target要执行的命令（任意的shell命令）。</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prerequisites中如果有一个以上的文件比target文件要新的话,recipe所定义的命令就会被执行。</span><br></pre></td></tr></table></figure><p>这就是makefile的规则，也就是makefile中最核心的内容。</p><p>说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile 的主线和核心，但要写好一个makefile还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。:)</p><h1 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h1><p>正如前面所说，如果一个工程有3个头文件和8个C文件，为了完成前面所述的那三个规则，我们的makefile 应该是下面的这个样子的。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>反斜杠（ <code>\</code> ）是换行符的意思。这样比较便于makefile的阅读。我们可以把这个内容保存在名字为“makefile”或“Makefile”的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件edit。如果要删除可执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就可以了。</p><p>在这个makefile中，目标文件（target）包含：可执行文件edit和中间目标文件（ <code>*.o</code> ），依赖文件（prerequisites）就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code> 文件又是可执行文件 edit 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的recipe行定义了如何生成目标文件的操作系统命令，一定要以一个 <code>Tab</code> 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><p>这里要说明一点的是， <code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像C语言中的label一样，其冒号后什么也没有，那么，<code>make</code>就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h1 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h1><p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，</p><ol><li><p><code>make</code>会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p></li><li><p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</p></li><li><p>如果<code>edit</code>文件不存在，或是<code>edit</code>所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</p></li><li><p>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么<code>make</code>会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</p></li><li><p>当然，你的C文件和头文件是存在的啦，于是<code>make</code>会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成<code>make</code>的终极任务，也就是可执行文件 <code>edit</code> 了。</p></li></ol><p>这就是整个<code>make</code>的依赖性，<code>make</code>会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么<code>make</code>就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，<code>make</code>根本不理。<code>make</code>只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有的目标文件，以便重编译。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。</p><p>而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。</p><h1 id="又一个示例（2024-5-20）"><a href="#又一个示例（2024-5-20）" class="headerlink" title="又一个示例（2024-5-20）"></a>又一个示例（2024-5-20）</h1><p><del>（爆笑）今天520，又是羡慕别人的一天。只有我这个…</del><br>有三个cpp文件，一个头文件。目录层级如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── functional.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">└── printhello.cpp</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure><p>main.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printhello</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;This is main:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The factorial of 5 is:&quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>factorial.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printhello.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>functional.h如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNCTIONAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNCTIONAL_H</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FUNCTIONAL_H</span></span></span><br></pre></td></tr></table></figure><p>如果不适用make工具进行编译，那么只需在命令行执行<code> g++ main.cpp factorial.cpp printhello.cpp -o main</code>一次性生成可执行文件。但是对于一个大项目来说，源文件和头文件往往百十个，每次编辑文件之后，需要执行很长的命令很费时，因此使用Makefile文件协助编译。</p><h2 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h2><p>只是简单的将命令写到Makefile文件里面，并没有进行简化。如果需要增加cpp文件，则需手动在Makefile文件里面修改。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 1</span></span><br><span class="line"> hello: main.cpp factorial.cpp printhello.cpp </span><br><span class="line">g++ -o hello main.cpp factorial.cpp printhello.cpp</span><br></pre></td></tr></table></figure><h2 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h2><p>这个版本才是真正的Makefile文件。利用依赖关系书写。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o </span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure><h2 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h2><p>相比于版本2，将编译参数单独拿出作为一个变量CXXFLAGS,使用<code>$@</code>代替目标文件，使用<code>$^</code>代替所有的依赖文件，使用<code>$&lt;</code>代理第一个依赖文件。<br>加入了clean目标，清空中间文件（所有的.o文件）和目标文件。<code>.PYTHON: clean</code>作用是避免和名字叫做clean的文件产生歧义，加入这行代码，检测到.PYTHON(伪目标)不存在，去找clean依赖，clean依赖不存在，执行<code>rm -f *.o $(TARGET)</code>命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o </span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h2><p>较于版本3，不在一个一个书写所有的依赖文件，而是利用wildcard和patsubst函数生成所有的依赖文件（.o文件）。这对庞大项目很有用处。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ##VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span> </span><br><span class="line"><span class="comment">#　$(wildcard &lt;PATTERN...&gt;)</span></span><br><span class="line"><span class="comment"># 返回make工作下的所有.cpp以及.c文件  </span></span><br><span class="line"><span class="comment"># $(wildcard *.cpp *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"><span class="comment"># $(patsubst  &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把字符串“x.c.c bar.c”符合模式%.c的单词替换成%.o，返回“x.c.o bar.o”。</span></span><br><span class="line"><span class="comment"># $(patsubst %.c,%.o,x.c.c bar.c)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 使用 $^ 表示所有的依赖文件，使用 $@ 表示目标文件名。</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖文件，使用 $@ 表示目标文件。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>第一次make：写好所有文件和Makefile文件，执行make，对所有文件编译链接等等，然后生成可执行文件。<br>第二次make: 第一次make之后没有对源文件做任何变化，因此显示已经是最新的。<br>第三次make：对factorial.cpp文件编辑之后，然后执行make。由于只改动了factorial.cpp文件，<strong>只对它单独进行编译</strong>，然后链接生成可执行文件。这是make的优势所在，只对改变的cpp文件编译，对引用修改的.h头文件的cpp文件进行编译。<br>make clean:删除所有.o和目标文件。<br><img src="/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/1.png"><br><img src="/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/2.png"></p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Necessary-Tools/">Necessary Tools</category>
      
      
      <category domain="https://HNUrookie1.github.io/tags/GUN-Make/">GUN Make</category>
      
      
      <comments>https://hnurookie1.github.io/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WORD学习笔记</title>
      <link>https://hnurookie1.github.io/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>https://hnurookie1.github.io/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 10 May 2024 07:46:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;S01入门-2024-04-10&quot;&gt;&lt;a href=&quot;#S01入门-2024-04-10&quot; class=&quot;headerlink&quot; title=&quot;S01入门(2024.04.10)&quot;&gt;&lt;/a&gt;S01入门(2024.04.10)&lt;/h1&gt;&lt;h2 id=&quot;1、操作名词：</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="S01入门-2024-04-10"><a href="#S01入门-2024-04-10" class="headerlink" title="S01入门(2024.04.10)"></a>S01入门(2024.04.10)</h1><h2 id="1、操作名词："><a href="#1、操作名词：" class="headerlink" title="1、操作名词："></a>1、操作名词：</h2><p> 选项卡，功能组，启动器，快捷工具栏，状态栏（视图状态），折叠（功能，页眉页脚）。</p><h2 id="2、操作习惯："><a href="#2、操作习惯：" class="headerlink" title="2、操作习惯："></a>2、操作习惯：</h2><p>1、保存和命名，随时CTRL+ s；用时间来命名；  </p><p>2、建立标准编辑环境：显示编辑标记，标尺，导航窗格；    </p><p>3、鼠标与键盘手势 （shift连续选择，ctrl跳跃选择，alt矩形选择；快速跳到开头或结尾）。  </p><p>4、快捷键<br>CTRL+C复制;<br>CTRL+V粘贴；<br>CTRL+Z撤销；<br>CTRL+Y前进；<br>按住CTRL不连续选择；<br>按住SHIFT连续选择；<br>按住ALT矩形框选；<br>单击ALT进入快捷键窗格模式（表现为选项卡出现格子）；<br>CTRL+B加粗；<br>CTRL+I倾斜；<br>CTRL+[&#x2F;]缩小、放大选中字体；<br>CTRL+(FN)+HOME&#x2F;END置顶&#x2F;到底；<br>CRTL+A全选；<br>CRTL+E&#x2F;L&#x2F;R 居中，左对齐，右对齐 CTRL+H 查找和替换 CTRL+（鼠标滚轮）缩放界面。  </p><h1 id="S02-排版实操讲解-204-04-11"><a href="#S02-排版实操讲解-204-04-11" class="headerlink" title="S02 排版实操讲解(204.04.11)"></a>S02 排版实操讲解(204.04.11)</h1><h2 id="一、段落格式"><a href="#一、段落格式" class="headerlink" title="一、段落格式"></a>一、段落格式</h2><p>1.换行符：SHIFT+ENTER(换行不换段落)</p><p>2.与格式刷：复制字体格式，不选段落标记；</p><p>复制段落格式，光标停留在相应区域；</p><p>TIP：单击格式刷：使用一次，双击：总是启用，直到取消。</p><h2 id="二、文本布局（先全局再细节）"><a href="#二、文本布局（先全局再细节）" class="headerlink" title="二、文本布局（先全局再细节）"></a>二、文本布局（先全局再细节）</h2><p>1.字体：字体选项卡，分别设置中英文；</p><p>2.段落:<br>①段落缩进：左侧，右侧，首行；</p><p>标尺：上面的小三角&#x3D;首行缩进，下面的方块三角&#x3D;段落全体缩进。</p><p>②设置行距。</p><h1 id="S03合同排版和修订-2024-4-11"><a href="#S03合同排版和修订-2024-4-11" class="headerlink" title="S03合同排版和修订(2024-4-11)"></a>S03合同排版和修订(2024-4-11)</h1><h2 id="一、合同的要素"><a href="#一、合同的要素" class="headerlink" title="一、合同的要素"></a>一、合同的要素</h2><p><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png"></p><h2 id="二、合同的排版"><a href="#二、合同的排版" class="headerlink" title="二、合同的排版"></a>二、合同的排版</h2><p>①字体和字号的对比突出重点。调整行距，利用页面空间，防止视觉疲劳。</p><p>②表格（去除框线）可以让落款整洁。</p><p>③适当使用横线、框线等来提升排版。标尺排版也要常用。设置段前段后行距，区分内容。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png"></p><p>TIP：.doc是指一个旧版的WORD文档。.docx那就是新版的。兼容模式之下很多功能无法使用。必须要转换。</p><h2 id="三、（合同）审阅功能"><a href="#三、（合同）审阅功能" class="headerlink" title="三、（合同）审阅功能"></a>三、（合同）审阅功能</h2><p>1.修订功能：</p><p>在 审阅 窗格内，点亮 修订 按钮即可进入。这可以用于团队文档修改。</p><p>在这个状态下，Backspace将不会删除文本，而是会出现红色删除线。同时，添加的文本也会是红色。</p><p>如果你修改了某些东西，将会在文档右侧的栏目中标记，显示。</p><p>但是，如果你没有看到上述界面（有时可能只会显示红线），在 审阅 的 修订 按钮旁边会有对标记显示的选项。你可以按照审阅需要勾选。</p><p>2.批注功能：</p><p>同样在 审阅 窗格内，有 批注 选项，可以进行旁栏批注。</p><p>3.注意事项：批注和修订的编辑、接受以及拒绝。</p><p>你会发现修订和批注的内容无法用常规编辑方式进行修改。</p><p>对于修订，同样在 审阅 窗格下，只有 接受 和 拒绝 两个可选。接受代表修订的内容可以继续存在，拒绝则撤回修订的所有操作。</p><p>对于批注，可以答复或者删除。</p><p>另外，批注和未被接受的修订不会被打印。</p><p>TIP：如果你的队友很遗憾的不会使用审阅功能，你可以另存为你的原文档，随后把他改过的在 审阅 选项卡 内进行 比较 功能运行即可。</p><h2 id="P4·合同保护和管理"><a href="#P4·合同保护和管理" class="headerlink" title="P4·合同保护和管理"></a>P4·合同保护和管理</h2><h1 id="S04邮件合并功能-2024-4-15"><a href="#S04邮件合并功能-2024-4-15" class="headerlink" title="S04邮件合并功能(2024-4-15)"></a>S04邮件合并功能(2024-4-15)</h1><p><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png"><br>邮件-&gt;选择收件人-&gt;选择现有列表，导入Excel数据源；在正文中将&lt;姓名&gt;，&lt;面试成绩&gt;选中’插入合并域’替换；之后，编辑’收件人列表’可以进行筛选，最后’完成合并’。</p><h1 id="S05学长分享-2024-4-22"><a href="#S05学长分享-2024-4-22" class="headerlink" title="S05学长分享(2024-4-22)"></a>S05学长分享(2024-4-22)</h1><p>形策课一位17级学长分享。<br>1、读研的意义是什么，自己想干嘛；<br>2、不要做i人，尽可能开口去问；<br>3、找工作面试的时候看完全公司的介绍；<br>4、工作拼的可能是体力，不是智力；<br>5、工作和学校不一样，请假不是一样的，职场没有借口。</p><h1 id="S06表格、图片、文字-2024-5-11"><a href="#S06表格、图片、文字-2024-5-11" class="headerlink" title="S06表格、图片、文字(2024-5-11)"></a>S06表格、图片、文字(2024-5-11)</h1><h2 id="1、表格：财务计算、大写金额"><a href="#1、表格：财务计算、大写金额" class="headerlink" title="1、表格：财务计算、大写金额"></a>1、表格：财务计算、大写金额</h2><p>计算采：用公式，可像excel里面输入单元格范围。注意：单击表格之后，工具栏上会出现新的“布局”选项卡，再单击“公式”。不是原来的“布局”选项卡。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png"><br>大写：“插入”-&gt;“编号”，选择大写数字，输入数字即可转换为大写金额。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png"></p><h2 id="2、图片（压缩）"><a href="#2、图片（压缩）" class="headerlink" title="2、图片（压缩）"></a>2、图片（压缩）</h2><p>对于标书中大量图片另存为的时候，点击“工具”-&gt;“压缩图片”，选择分辨率。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png"></p><h2 id="3、标书制作"><a href="#3、标书制作" class="headerlink" title="3、标书制作"></a>3、标书制作</h2><p>太晚了，明天写。<br>2024-5-10更。</p><ol><li>编号习惯</li></ol><ul><li>阿拉伯数字后带原点</li><li>汉字数字后用顿号</li><li>带括号的序号和带圈序号，后面不加标点符号，且带括号的序号一般不超过10</li></ul><ol start="2"><li>标书文件格式<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%87%E4%B9%A6.png"><br>注意修改完之后：一级标题前通常要“段前分页”，附录前面也要“段前分页”。建议新建“样式”-&gt;“附件”，方便统一管理。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%99%84%E4%BB%B6%E6%A0%B7%E5%BC%8F.png"><br>使用通配符替换掉原有标题前的序号，应用格式要求中的多级列表编号。(?)-&gt;空，?、-&gt;空。(英文?,中文、)<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%87%E4%B9%A62.png"></li></ol><h1 id="S07表格辅助排版-表格疑难杂症-表格美化-三线表-2024-5-12"><a href="#S07表格辅助排版-表格疑难杂症-表格美化-三线表-2024-5-12" class="headerlink" title="S07表格辅助排版&#x2F;表格疑难杂症&#x2F;表格美化&#x2F;三线表(2024-5-12)"></a>S07表格辅助排版&#x2F;表格疑难杂症&#x2F;表格美化&#x2F;三线表(2024-5-12)</h1><h2 id="辅助排版："><a href="#辅助排版：" class="headerlink" title="辅助排版："></a>辅助排版：</h2><p>1、封面&#x2F;落款&#x2F;公文头：<br>卫生局文件<br>妇女联合会<br>2、用表格排版图片：固定列宽,tab键移动到下一个单元格，制作完后表格整体居中。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC1.png"></p><h2 id="表格疑难杂症："><a href="#表格疑难杂症：" class="headerlink" title="表格疑难杂症："></a>表格疑难杂症：</h2><p>1、表格超过页面，右侧文字看不见<br>    全选表格-&gt;布局-&gt;自动调整-&gt;根据窗口自动调整表格。原因是因为粘贴表格前后的宽度不一致。也可以调整布局-&gt;纸张大小,增大宽度。建议使用表格的自动调整。<br>2、表格底部文字被遮挡<br>    原因是因为表格行高的问题。<br>调整方法：表格属性-&gt;指定高度-&gt;最小值。最小值情况下表格高度会保证最少容纳所有文字。<br>3、长表格跨页断行（明明是一个表格，却没放在一个页面）<br>    调整方法：表格属性-&gt;行-&gt;允许跨页断行。<br>4、如何去除表格后面的空白页<br>    原因：新建word换行的段落标记因为被表格占据，导致第一个页面放不下该段落标记，所以段落标记跑到了第二页。<br>    调整方法：i.行高改为小值，如1磅。ii.将页边距的上下调小，使得放下段落标记。</p><h2 id="表格美化："><a href="#表格美化：" class="headerlink" title="表格美化："></a>表格美化：</h2><p>1、自定义：居中对齐，留白，弱化表格的束缚感，清晰整洁：边框采用浅色，如灰色；标题行应用底纹。<br>2、使用自带的样式。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC2.png"></p><h2 id="三线表："><a href="#三线表：" class="headerlink" title="三线表："></a>三线表：</h2><p>边框取消；标题行：上边框粗，下边框细；汇总行：下边框粗；创建新的表格样式“三线表”，每次插入表格就可以直接应用“三线表”。(这种方法似乎不可行)<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC3.png"><br>另一种办法：<br>切换到【插入】选项卡，在【表格】组中，单击【表格】的下三角按钮，在弹出的列表中将鼠标移动至【快速表格】按钮，弹出下一级菜单，在此，点击最下方的【将所选内容保存到快速表格库】按钮。弹出【新建构建基块】对话框，设置名称，并简单说明表格作用，单击【确定】按钮，即可完成表格添加到快速表格库中。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC4.png"></p><h1 id="S08查找替换功能-2024-5-13"><a href="#S08查找替换功能-2024-5-13" class="headerlink" title="S08查找替换功能(2024-5-13)"></a>S08查找替换功能(2024-5-13)</h1><h2 id="设置填空题"><a href="#设置填空题" class="headerlink" title="设置填空题"></a>设置填空题</h2><p>ctrl选择任意位置几处文字，字体颜色设置为红色。ctrl+h替换，将“红色”的字体替换为“下划线”，字体设置为白色，下划线颜色设置为黑色。设置完之后效果。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/S08-1.png"></p><h2 id="批量删除图片（嵌入型）"><a href="#批量删除图片（嵌入型）" class="headerlink" title="批量删除图片（嵌入型）"></a>批量删除图片（嵌入型）</h2><p>替换选项里面，特殊格式图片(^g)替换为空。可在选项卡里面设置插入图片类型默认为“嵌入型”。删除之后若出现多个空白行，也就是多个段落标记，“替换”选项里面将多个段落标记替换为一个，删除多余空白行。<br>此外，替换选项还有多种功能。如将特定文字应用为标题样式：查找【四号字体、加粗】，替换为【样式、标题一】。</p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Necessary-Tools/">Necessary Tools</category>
      
      
      <category domain="https://HNUrookie1.github.io/tags/WORD/">WORD</category>
      
      
      <comments>https://hnurookie1.github.io/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>希尔排序、快速排序、合并排序</title>
      <link>https://hnurookie1.github.io/2024/05/09/%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/</link>
      <guid>https://hnurookie1.github.io/2024/05/09/%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/</guid>
      <pubDate>Wed, 08 May 2024 16:49:41 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h3&gt;&lt;p&gt;希尔(shell)排序是插入排序的一种。也称&lt;strong&gt;缩小增量排序&lt;/strong&gt;，是直接插入排序的一种更高效的改进</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔(shell)排序是插入排序的一种。也称<strong>缩小增量排序</strong>，是直接插入排序的一种更高效的改进版本。希尔排序是非稳定排序。希尔排序是按照记录下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量减少，每组包含的关键词增多，当增量减少至1时，所有元素被分为1组，算法结束。<br>我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。而如上面这样分完组后，就各自排序的方法达不到我们的要求。因此，我们需要采取<strong>跳跃分割</strong>的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br><img src="/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort</span><span class="params">(E A[],<span class="type">int</span> n,<span class="type">int</span> incr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = incr;i &lt; n;i += incr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i;(j &gt; incr) &amp;&amp; (A[j] &lt; A[j-incr]);j -= incr)</span><br><span class="line">      <span class="built_in">swap</span>(A,j,j - incr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>;i &gt; <span class="number">2</span>;i /= <span class="number">2</span>)<span class="comment">//增量从n/2开始，直到增量为2，增量为1的单独处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">      <span class="built_in">inssort</span>&lt;E&gt;(A[j],n-j,j);<span class="comment">//从j处开始,n-j处结束</span></span><br><span class="line">  <span class="built_in">inssort</span>&lt;E,Comp&gt;(A,n,<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>一趟快速排序思想</strong><br>1、目标：找一个记录，以它的关键字作为<strong>枢轴</strong>，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。致使一趟排序之后，记录的无序序列A[s..t]将分割成两部分：<br>A[s..i-1]和A[i+1..t]，且A[j].key(左边)≤ A[i].key(枢轴) ≤ A[k].key(右边)<br>2、首先对无序的记录序列进行“一次划分”，之后分别对分割所得的两个子序列“递归”进行快速排序。<br><img src="/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png" alt="快排1"><br>3、一趟快速排序的过程<br>a.  首先选定轴，交换轴与最后一个元素；(最后要交换回来)<br>b. 设定l指针指向第一个元素前的位置，r指向最后元素；<br>c. 先移动l，遇到比轴大则停止；再移动r，遇到比轴小停止，交换l和r所指元素。<br>d. 持续执行上一步，直到l和r相遇；<br>e. 将最后一个元素和停止时l(r)位置的元素交换。<br><img src="/images/%E5%BF%AB%E6%8E%922.png"><br>4、代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findpivot</span><span class="params">(E A[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (i+j)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="comment">/*1、内联函数，编译时直接替换成函数体的内容，避免对栈空间的重复消耗;</span></span><br><span class="line"><span class="comment">2、返回枢轴的下标；取中间、第一个、最后一个都可以。*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(E A[],<span class="type">int</span> l,<span class="type">int</span> r,E&amp; pivot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(A[++l] &lt; pivot);<span class="comment">//当左边l所指元素小于枢轴，一直向右寻找，直到大于枢轴，停止</span></span><br><span class="line">    <span class="keyword">while</span>((l &lt; r) &amp;&amp; A[--r] &gt; pivot);</span><br><span class="line">    <span class="built_in">swap</span>(A,l,r);</span><br><span class="line">  &#125;<span class="keyword">while</span>(l &lt; r)</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(E A[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="comment">//i代表左指针，j代表右指针</span></span><br><span class="line">  <span class="keyword">if</span>(j &lt;= i)<span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> pivotindex = <span class="built_in">findpivot</span>(A,i,j);</span><br><span class="line">  <span class="comment">/*这里之所以调用函数，是为了后续的可扩展性和修改：</span></span><br><span class="line"><span class="comment">  假如要取第一个元素为枢轴，直接修改findpivot函数即可，</span></span><br><span class="line"><span class="comment">  不用修改qsort函数主体*/</span></span><br><span class="line">  <span class="built_in">swap</span>(A,pivotindex,j);<span class="comment">//把枢轴放到最后</span></span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">partition</span>&lt;E&gt;(A,i<span class="number">-1</span>,j,A[j]);<span class="comment">//k为左右指针相遇的地方</span></span><br><span class="line">  <span class="built_in">swap</span>(A,k,j);<span class="comment">//把枢轴交换回来</span></span><br><span class="line">  <span class="comment">/*把轴交换回位置k，意味着轴把k前后的数据一分为二*/</span></span><br><span class="line">  <span class="built_in">qsort</span>&lt;E&gt;(A,i,k<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">qsort</span>&lt;E&gt;(A,k+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、时间复杂度<br>假设一次划分所得枢轴位置 i&#x3D;k，则对n个记录进行快排所需时间：<br>　　　　T(n) &#x3D; Tpass(n) + T(k-I) + T(n-k),<br>其中 Tpass(n)为对 n 个记录进行一次划分所需时间。<br>若待排序列中记录的关键字是随机分布的，则 k 取 1 至 n 中任意一值的可能性相同。<br>由此可得快速排序所需时间的平均值为：<br><img src="/images/%E5%BF%AB%E6%8E%923.png"><br><strong>结论</strong>：<br>快速排序的时间复杂度为O(nlogn)。<br>若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n^2)。</p><h3 id="合并（归并）排序"><a href="#合并（归并）排序" class="headerlink" title="合并（归并）排序"></a>合并（归并）排序</h3><p>算法思想：<br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F1.png"><br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F2.png"><br>例如：<br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F3.png"><br>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;tyepname E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(E A[],E temp[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*合并排序算法虽说也是O(nlogn)，但是使用了临时数组temp，  </span></span><br><span class="line"><span class="comment">  因此STL中的sort()函数一般采用快排(当然还有其他算法的加速)，  </span></span><br><span class="line"><span class="comment">  而非合并排序*/</span></span><br><span class="line">  <span class="keyword">if</span>(left == right) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E&gt;(A,temp,left,mid);</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E&gt;(A,temp,mid+<span class="number">1</span>,right);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = left;i &lt;= right;i ++)<span class="comment">//将原数组内容复制到临时数组</span></span><br><span class="line">    temp[i] = A[i];</span><br><span class="line">  <span class="type">int</span> i1 = left,i2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr = left; curr &lt;= right;curr ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == mid + <span class="number">1</span>)<span class="comment">//如果左边的一半已经到头，直接把右边剩下的复制给原数组</span></span><br><span class="line">      A[curr] = temp[i2++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt; right)</span><br><span class="line">      A[curr] = temp[i1++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp[i1] &lt; temp[i2])<span class="comment">//取小的赋给原数组</span></span><br><span class="line">      A[curr] = temp[i1++];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      A[curr] = temp[i2++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)<br>时间复杂度：O(n)</p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://HNUrookie1.github.io/tags/algorithm/">algorithm</category>
      
      
      <comments>https://hnurookie1.github.io/2024/05/09/%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>三种O(n^2)的排序算法</title>
      <link>https://hnurookie1.github.io/2024/05/08/%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <guid>https://hnurookie1.github.io/2024/05/08/%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Tue, 07 May 2024 16:20:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;排序算法的稳定性&lt;/strong&gt;：所有相等的数经过某种排序方法后，仍能保持它们在排序前的相对次序，我们称这种排序算法是稳定的。反之，就是非稳定算法。&lt;br&gt;&lt;strong&gt;内排序&lt;/strong&gt;：在排序过程中，所有需要排序的数都在内存，并在内存中调整它们</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>排序算法的稳定性</strong>：所有相等的数经过某种排序方法后，仍能保持它们在排序前的相对次序，我们称这种排序算法是稳定的。反之，就是非稳定算法。<br><strong>内排序</strong>：在排序过程中，所有需要排序的数都在内存，并在内存中调整它们的顺序，称为内排序。<br><strong>外排序</strong>：在排序过程中，只有部分数被调入内存，并借助内存调整数在外存中的相对顺序，称为外排序。  </p><h5 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h5><p>分三个步骤：</p><ul><li>在在A[1..i-1]中查找A[i]的插入位置，A[1..j].key &lt;&#x3D; A[i].key &lt; A[j+1..i-1].key;</li><li>将A[j+1..i-1]中的所有记录均后移一个位置;</li><li>将A[i]插入(复制)到A[j+1]的位置上。<br><img src="/images/insort.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i;(j&gt;<span class="number">0</span>) &amp;&amp; (Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]);j --))<span class="comment">//如果A[j]&gt;A[j-1],交换</span></span><br><span class="line">      <span class="built_in">swap</span>(A[j],A[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h5><p><img src="/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//标记此次冒泡过程中是否交换了元素，没有的话说明元素已经有序，终止</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = n - <span class="number">1</span>;j &gt; i;j --)<span class="comment">//从后向前冒泡，从前往后也一样</span></span><br><span class="line">      <span class="keyword">if</span>(Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]))<span class="comment">//如果A[j]&gt;A[j-1]</span></span><br><span class="line">      &#123;<span class="built_in">swap</span>(A,j,j<span class="number">-1</span>);flag = True;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h5><p><img src="/images/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png"><br>假设当前下标为最小值的下标，向后遍历，一直更新最小值的下标，找到尽头，交换最小值和当前值。更新当前下标，持续上述，直至当前下标为最后一个元素下标。<br>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(T arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j,min;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">    min = i;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; len;j ++)</span><br><span class="line">      <span class="keyword">if</span>(arr[min] &gt; arr[j])</span><br><span class="line">        min = j;</span><br><span class="line">      <span class="built_in">swap</span>(arr[i],arr[min]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Algorithm/">Algorithm</category>
      
      
      
      <comments>https://hnurookie1.github.io/2024/05/08/%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我是谁，我是一个什么样的人</title>
      <link>https://hnurookie1.github.io/2024/03/04/%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/</link>
      <guid>https://hnurookie1.github.io/2024/03/04/%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/</guid>
      <pubDate>Sun, 03 Mar 2024 16:00:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;有人为了家族兴旺而活，他觉得自己的人生很有价值，很幸福；也有人无所羁绊，只为了自由而活，他也觉得自己很幸福。&lt;br&gt;有人奔波忙碌，但是精神饱满，斗志昂扬；也有人平平淡淡，也知足常乐，过的安详。&lt;br&gt;我们总想探讨哪种人才是人生的真谛，这些到底是对是错？但其实大多时候，不过是</description>
        
      
      
      
      <content:encoded><![CDATA[<p>有人为了家族兴旺而活，他觉得自己的人生很有价值，很幸福；也有人无所羁绊，只为了自由而活，他也觉得自己很幸福。<br>有人奔波忙碌，但是精神饱满，斗志昂扬；也有人平平淡淡，也知足常乐，过的安详。<br>我们总想探讨哪种人才是人生的真谛，这些到底是对是错？但其实大多时候，不过是基于你的精神世界，哪种是你真实想要的罢了。<br>人生的悲剧不在于你选了哪种，而在于你所选的，不是你真心认可的。例如：周围的人，都跟你说，考个编，过个安稳日子才是最香的。<br>这话对不对？对于那些真心认可这种生活的人就对，而对于那些没有主见，不知道自己想要什么的人未必就对。<br>所以，一切都回到了起点，先搞清楚“我是谁？我是一个什么样的人”的问题，这很重要。</p><p><img src="/images/%E6%9C%88%E5%85%89%E4%B9%8B%E4%B8%8B.jpg" alt="月光之下"></p>]]></content:encoded>
      
      
      <category domain="https://HNUrookie1.github.io/categories/Life-Record/">Life Record</category>
      
      
      
      <comments>https://hnurookie1.github.io/2024/03/04/%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
