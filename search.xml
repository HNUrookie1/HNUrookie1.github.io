<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大学三年的总结</title>
      <link href="//2024/10/01/%E5%A4%A7%E5%AD%A6%E4%B8%89%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>//2024/10/01/%E5%A4%A7%E5%AD%A6%E4%B8%89%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>留个坑，后面再写。</p>]]></content>
      
      
      <categories>
          
          <category> Life Record </category>
          
      </categories>
      
      
        <tags>
            
            <tag> University </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poem</title>
      <link href="//2024/09/21/Poem/"/>
      <url>//2024/09/21/Poem/</url>
      
        <content type="html"><![CDATA[<h1 id="《孙权劝学》司马光"><a href="#《孙权劝学》司马光" class="headerlink" title="《孙权劝学》司马光"></a>《孙权劝学》司马光</h1><p>初，权谓吕蒙曰：“卿今当涂掌事，不可不学！”蒙辞以军中多务。权曰：“孤岂欲卿治经为博士邪！但当涉猎，见往事耳。卿言多务，孰若孤？孤常读书，自以为大有所益。”蒙乃始就学。及鲁肃过寻阳，与蒙论议，大惊曰：<strong>“卿今者才略，非复吴下阿蒙！”</strong>蒙曰：<strong>“士别三日，即更刮目相待，大兄何见事之晚乎！”</strong>肃遂拜蒙母，结友而别。</p><p>译文：</p><p>起初，孙权对吕蒙说：“你现在掌管政事，不可以不学习！”吕蒙用军中事务繁多来推托。孙权说：“我难道想要你研究儒家经典，成为专掌经学传授的学官吗？我只是让你应当粗略地阅读，了解历史。你说军务繁多，谁比得上我事务多呢？我经常读书，自己觉得获益颇多。”吕蒙于是开始学习。等到鲁肃到寻阳的时候，鲁肃和吕蒙一起讨论议事，鲁肃十分吃惊地说：“你现在军事方面的才干和谋略，不再是在吴下时没有才学的阿蒙了！”吕蒙说：“与读书的人分别几天，就应当用新的眼光看待，大兄你知晓事情为什么这么晚呢？”于是鲁肃拜见吕蒙的母亲，和吕蒙结为好友后离开了。</p><p>感悟：</p><p>我们不能以一成不变的事物看待他人，要以开放的眼光看待事物。</p><h1 id="《念奴娇·赤壁怀古》苏轼"><a href="#《念奴娇·赤壁怀古》苏轼" class="headerlink" title="《念奴娇·赤壁怀古》苏轼"></a>《念奴娇·赤壁怀古》苏轼</h1><p>大江东去，浪淘尽，千古风流人物。<br>故垒西边，人道是，三国周郎赤壁。<br>乱石穿空，惊涛拍岸，卷起千堆雪。<br>江山如画，一时多少豪杰。</p><p><strong>遥想公瑾当年，小乔初嫁了，雄姿英发。</strong><br>羽扇纶（guan）巾，谈笑间，樯橹灰飞烟灭。(樯橹 一作：强虏)<br>故国神游，多情应笑我，早生华发。<br>人生如梦，一尊还酹（lei）江月。(人生 一作：人间；尊 同：樽)</p><p>译文：</p><p>滚滚长江向东奔流而去，千百年来奔腾不息的滔滔巨浪淘尽了多少杰出的英雄人物。<br>旧日营垒的西边，有人说，那儿是三国时周瑜大破曹军的赤壁。<br>只见陡峭纷乱的岩壁耸入云霄，汹涌澎湃的巨浪拍打着江岸，卷起无数堆雪白的浪花。<br>雄壮的江山奇丽如画，一时间涌现了多少英雄豪杰。<br>我不禁遥想起当年的周公瑾，美丽的小乔刚嫁给他，英姿雄健风度翩翩神采照人。<br>手摇羽扇，头戴纶巾，谈笑之间，就将曹军的战船烧得灰飞烟灭。<br>如今我身临古战场神游往昔，应笑我多愁善感，以至于过早生出了白发。<br>人生在世犹如大梦一场，还是洒一杯酒祭献给江中伴我的明月吧！</p><p>感悟：</p><p>经历诸多事情后，才明白”遥想公瑾当年，小乔初嫁了，雄姿英发“是多么的意气风发、风华正茂。</p><h1 id="《寒窑赋》北宋-吕蒙正"><a href="#《寒窑赋》北宋-吕蒙正" class="headerlink" title="《寒窑赋》北宋 吕蒙正"></a>《寒窑赋》北宋 吕蒙正</h1><p>天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇；雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往；人有冲天之志，非运不能自通。</p><p>盖闻：人生在世，富贵不能淫，贫贱不能移。文章盖世，孔子厄于陈邦；武略超群，太公钓于渭水。颜渊命短，殊非凶恶之徒；盗跖年长，岂是善良之辈。尧帝明圣，却生不肖之儿；瞽叟愚顽，反生大孝之子。张良原是布衣，萧何称谓县吏。晏子身无五尺，封作齐国宰相；孔明卧居草庐，能作蜀汉军师。楚霸虽雄，败于乌江自刎；汉王虽弱，竟有万里江山。李广有射虎之威，到老无封；冯唐有乘龙之才，一生不遇。韩信未遇之时，无一日三餐，及至遇行，腰悬三尺玉印，一旦时衰，死于阴人之手。</p><p>有先贫而后富，有老壮而少衰。满腹文章，白发竟然不中；才疏学浅，少年及第登科。深院宫娥，运退反为妓妾；风流妓女，时来配作夫人。</p><p>青春美女，却招愚蠢之夫；俊秀郎君，反配粗丑之妇。蛟龙未遇，潜水于鱼鳖之间；君子失时，拱手于小人之下。衣服虽破，常存仪礼之容；面带忧愁，每抱怀安之量。时遭不遇，只宜安贫守份；心若不欺，必然扬眉吐气。初贫君子，天然骨骼生成；乍富小人，不脱贫寒肌体。</p><p>天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。注福注禄，命里已安排定，富贵谁不欲?人若不依根基八字，岂能为卿为相?</p><p>吾昔寓居洛阳，朝求僧餐，暮宿破窖，思衣不可遮其体，思食不可济其饥，上人憎，下人厌，人道我贱，非我不弃也。今居朝堂，官至极品，位置三公，身虽鞠躬于一人之下，而列职于千万人之上，有挞百僚之杖，有斩鄙吝之剑，思衣而有罗锦千箱，思食而有珍馐百味，出则壮士执鞭，入则佳人捧觞，上人宠，下人拥。人道我贵，非我之能也，此乃时也、运也、命也。</p><p>嗟呼！人生在世，富贵不可尽用，贫贱不可自欺，听由天地循环，周而复始焉。</p><blockquote><p>感悟：时也命也！</p></blockquote><h3 id="《离思五首·其四》元稹"><a href="#《离思五首·其四》元稹" class="headerlink" title="《离思五首·其四》元稹"></a>《离思五首·其四》<strong>元稹</strong></h3><p>曾经沧海难为水，除却巫山不是云。</p><p>取次花丛懒回顾，半缘修道半缘君。</p><h3 id="《飞鸟集》片段-泰戈尔"><a href="#《飞鸟集》片段-泰戈尔" class="headerlink" title="《飞鸟集》片段 泰戈尔"></a>《飞鸟集》片段 <strong>泰戈尔</strong></h3><p>浮世三千，吾爱有三，日月与卿，日为朝，月为暮，卿为朝朝暮暮。</p><h3 id="《鹊桥仙》-秦观"><a href="#《鹊桥仙》-秦观" class="headerlink" title="《鹊桥仙》 秦观"></a>《鹊桥仙》 <strong>秦观</strong></h3><p>纤云弄巧，飞星传恨，银汉迢迢暗度。金风玉露一相逢，便胜却人间无数。</p><p>柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮。</p><h3 id="《江城子·乙卯正月二十日夜记梦》-苏轼"><a href="#《江城子·乙卯正月二十日夜记梦》-苏轼" class="headerlink" title="《江城子·乙卯正月二十日夜记梦》 苏轼"></a>《江城子·乙卯正月二十日夜记梦》 <strong>苏轼</strong></h3><p>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。</p><p>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p><h3 id="《上邪》"><a href="#《上邪》" class="headerlink" title="《上邪》"></a>《上邪》</h3><p>上邪！我欲与君相知，长命无绝衰。山无陵，江水为竭，冬雷震震，夏雨雪，天地合，乃敢与君绝。 </p><h3 id="《马嵬·其二》-唐-李商隐"><a href="#《马嵬·其二》-唐-李商隐" class="headerlink" title="《马嵬·其二》 唐 李商隐"></a>《马嵬·其二》 <strong>唐 李商隐</strong></h3><p>海外徒闻更九州，他生未卜此生休。</p><p>空闻虎旅传宵柝，无复鸡人报晓筹。</p><p>此日六军同驻马，当时七夕笑牵牛。</p><p>如何四纪为天子，不及卢家有莫愁。</p><blockquote><p>感悟：这几首诗词均与爱情有关，或许只有经历过才能明白其中的酸甜与苦楚吧。</p></blockquote><h3 id="《蒲松龄自勉联》"><a href="#《蒲松龄自勉联》" class="headerlink" title="《蒲松龄自勉联》"></a>《蒲松龄自勉联》</h3><p>有志者，事竟成，破釜沉舟，百二秦关终属楚；</p><p>苦心人，天不负，卧薪尝胆，三千越甲可吞吴。</p><blockquote><p>感悟：高中时常常以此自勉。</p></blockquote><h3 id="《蝶恋花》-柳永"><a href="#《蝶恋花》-柳永" class="headerlink" title="《蝶恋花》 柳永"></a>《蝶恋花》 <strong>柳永</strong></h3><p>伫倚危楼风细细，望极春愁，黯黯生天际。草色烟光残照里，无言谁会凭阑意。</p><p>拟把疏狂图一醉，对酒当歌，强乐还无味。衣带渐宽终不悔，为伊消得人憔悴。</p><blockquote><p>感悟：柳永漂泊异乡，苦于见不到意中人的沮丧与忧愁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Poem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是谁，我是一个什么样的人</title>
      <link href="//2024/08/05/%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/"/>
      <url>//2024/08/05/%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>有人为了家族兴旺而活，他觉得自己的人生很有价值，很幸福；也有人无所羁绊，只为了自由而活，他也觉得自己很幸福。<br>有人奔波忙碌，但是精神饱满，斗志昂扬；也有人平平淡淡，也知足常乐，过的安详。<br>我们总想探讨哪种人才是人生的真谛，这些到底是对是错？但其实大多时候，不过是基于你的精神世界，哪种是你真实想要的罢了。<br>人生的悲剧不在于你选了哪种，而在于你所选的，不是你真心认可的。例如：周围的人，都跟你说，考个编，过个安稳日子才是最香的。<br>这话对不对？对于那些真心认可这种生活的人就对，而对于那些没有主见，不知道自己想要什么的人未必就对。<br>所以，一切都回到了起点，先搞清楚“我是谁？我是一个什么样的人”的问题，这很重要。</p><p><img src="/images/%E6%9C%88%E5%85%89%E4%B9%8B%E4%B8%8B.jpg" alt="月光之下"></p>]]></content>
      
      
      <categories>
          
          <category> Life Record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>吃一堑长一智</title>
      <link href="//2024/08/05/%E5%90%83%E4%B8%80%E5%A0%91%E9%95%BF%E4%B8%80%E6%99%BA/"/>
      <url>//2024/08/05/%E5%90%83%E4%B8%80%E5%A0%91%E9%95%BF%E4%B8%80%E6%99%BA/</url>
      
        <content type="html"><![CDATA[<p>前几天接了一个python大作业，要求是爬取一个文本数据，然后进行数据分析，代码比较简单而且有模板可以套用。想说的是什么：事先一定要和甲方谈好需求，包括他们在哪里要求跑程序。这次就是没说清环境，我在本地跑的好好的，到了甲方那里不会配置环境，结果又帮他配置环境，到头来搞得很麻烦。所以说，和甲方讲好需求很重要。</p>]]></content>
      
      
      <categories>
          
          <category> Life Record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//2024/08/05/hello-world/"/>
      <url>//2024/08/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>放假反省</title>
      <link href="//2024/07/13/%E6%94%BE%E5%81%87/"/>
      <url>//2024/07/13/%E6%94%BE%E5%81%87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e1a25cea275faabdb9aa8d25860458cf8609cbf597e9716534839f830665c9f">54e3726371269f5f4d16eecc3c6bcb4294d1ceff3847bbb1c1d7111be0949bb9f104514ddc5434542afeee4f4852693891615e7a4e810e7a0c99ee305a051e97e2bfb026ce43aa1ad064f5a1d980d72e4e05ae2f8bd35f761bbf68f5e49ae0f6cd615672be48511a35bcab13e8f30836959297a0d79fb610988f66becb0269f1006cce64282c49e5778a527a633e375ccf90969df7969808a24c7620d7ad987324e9a730be5bb24e1a717f879d91451b7ff0f257497c8044452e834bd089eea1c53bd15beb0c1015daa435a43afd230756e29743f1518115998c70e7556cc5089e35992458fef1dc5e398936ed53c0fafdb3949c33d7f597b0f85f810b52b0a55246ef81c3017bd2f599ad3068dfa15a62301976c219b74ffbc8cb9782f763a25cdaf35fcb758b1e3c47a221e25c86d6c673d1f90ca67809642b3c35ccf9b4ed91a44275750b4214174b7b811ec9453729883bec1e497e3b3e895a4cb8e317b263f50c91c3107e81e4d92305cee1fd252e72efb3f1ee73fffc93247341dc0f8a86824289687ecf88e4721248d0826be749d07ccd62f5f097311c3d3c96a2ffffcf7b94659a5375a133698fad7ea6448b391abfa9ca0167707effeafcbc2529d90fe7f391710a49ec0180896c66bb7b0f73c7184f093e0eefe621c33173402171dcf8eaef45bbcaa1395c138ab1cee75139b7e827c2352989fcd87ba703440377c08deebe0478359e0f5ec33c659eb0e24397fa1a2422b160dc13dbf59b49664008c036a5baebbc3d878fe798aae2f9d273ad592420a214e287d81fda9d763c86b62375095603a8d0a2b82807def84908a791a58de4c96b5626f3f9ea590d70cf30ebd62b076b55bd33de0e76874c974d7afe3d2c4135888f7a36eebcce04ba07d83699216df408eda85adaae8f28d35ba37c2ae9929bab2fc5099838b2d89f1a272faf47e72a25596da61ce4e1b8f96b56e0a7e3f9a12f0c7c13f27508fce5537834132272d9b12c16d8bc8bfb5fb17a4b6dfa9fd054b131c48db7d9d79eefb47c3b4f4ab04feaf8d1faebbb9cae6bdc6d42e9de3bb9ebe70e0655c0c39695a856e89b50b515b2c00379e22ded6702b180723069aabb06c4c40a267d321256b8387d7004bcef11360dd3320e2b3aca5d6047713f17a27bb503a5e376d51ae4f9b2010d91341eaa20db41eef0d8efc0b71c3139e65e6e6268bfc08503f3a8fb55b7a2dad80f12f7d91b3c0179b0740485100b18ec6484686720e7cae3c64a89d5138db29da166fc1232332cac2c7369cce06a4c6fa04e09e2f2d555b731b4620db198b285923ef0e419959a05ad3efdd766e12dbe859de953bb5d20c29e5cc596144c28fbeafef74416c0c8fa79d0a5a353eee6fbd5558fef9d38f6be6fec95def465f1fe598d622ffca8f0c3631d5eb748d74542c3c99c6474916e2da96efa09c93790fd6e9acd22572c1c7175407048bc326efa182cd717777bcec3a750eb5840a9cf3d3d9de106b5593ca681cf80df347ec67f4b22a2dea7087c76b585557744beed338cd20f49b7ce0e68d74965a40e72bdb54bb2dd0a3a60ba70fdadd2cf2a4f2a9fd9b831364d352e17f34ecec39c0c195ef1510d51bbacd4926c1811a980803bee50c7b3518e7ac024257c0728b4a9c3ac9e440f669761827e63f12bfebf4eed3868d3a309fffb6f4c34d415e6b9389164368925d701f06666dc2155dba5a416a71ca53dd3901701aea3daa09778d2d2e0b1a2ebe3995045c26c385424e90360b17559becb277ec3b1fd75fcc37698c96bc7180eb7b26f2cec8be5dd873c4d07b4415ffe825b9afa63d6450c417f4c8670db5819407f637e3e19b4061ef948627b0558428d355e40f9642affe8cb1215f8b440d570493b6de21480be16ac7625b62e30d3ea47500c39406e8603826f43846f79c1d9ca000bb302e36ff9f4ebde7248323586484a2d572990599607145134ad8225c3c3be3146583953590853ee1a4290f5eac09e9465b9cb9bc9e53eacb4032c83666d20ea893e95f34d97e6ddc630e7d1b7fe983ef357557af6b6c671fc53dce10724478b5c3556d6dadd2d578cf29b968ab29ea3223667f20a386a3376e83a7d352602543e276fdcbdc64ab331120895bcc5e722deea93e5c04e15c0ff438c6434d6d54ce21afe043b8974fd9ec1e0ebd58116c44406395030ce6c874c058a3319febd031d1122b0fefc5d257a8e020fa158416c095c9b129066504d1fd6517ee1f2f11ef1ad429a3f34f7782bb7bb4436ba244fd5f490182e943c4e349e39290a93b97e829253ee218609165bf8adc02acb521a0db14c83fb2f541424936be3558ea7c87b2ca0ba34e0039a0ddb439dd227b528d9dcff6b9f29f0cef4550d2fdc2761ea48e3f8b4540e89d02a6a86228959e4fe473a7a8a14846e230724b5b67cf85db00781d404864bd66ff52c10a88c30561c203e5b2dbb2efdfffad2b3830488af33cfdd20aa3b75e651596759cf20e7a87401437ede28340dd59603ed765a02b4eb7e0263425e0e9a22d80a5229c3b1180b9094c342c7dad1f7382dc80283d800b083b6fff1f87abcf914ce2bddaceb2f92b3bd733e3a7ddc7c8453c7062ce1ea4ef08e52a9bb4c8bd61e000498ee693bbd4cd3cfce62f0e1d8482e3c7a8f4f80757a5c3edb5a1e98dc064b9ad53f1b8d32c39e2b93d6548d818cebdc182c0c7e0eaae6ead1851fd4bcf28685300d153088a89689c7fcd4c9422a5b937282b42afedf658378aedf90f33a4668e1d4308b21571b25b22c529c81210c48fd9c523096f54ce723c4f8504aff331ced508779068cbf0ad1f9dc8f4c8d371e6e05fb00fdd93fa6d2d3f512223f314b256f6f56cfa4669142bb209f4a7224d50e1863c4a47ea337bc027f81b8a31fabea8df5e328566b06b56d42b426806b8a26ae53859d6c36dae5f713f071c30589156da5bf5711d5995c1ee26d8420243c63afa63d528ac1d365cd4677c13f89d221fbe3c7480186cd6737405cecdc023fc729fed4dba80306c1939dfa3fc93b30b6bb2e9d14e8a1f977c415e14fc634a56ba7f61f315aa143f7760288383a7bd6d52d21c86c088af7770176aff7f50805e6fdbe50a5a98619f7503746f2baa2f04e91a23c61ddd00fa7df33609b68a3d07b20f5a93d3f4c81d48e000c71de237c4e6133e713dc47a1dffaa9a3f4a3adee35029f7fce8a10f566b7b5301b1c885b8c5882aa718efb159497f3deec0cf68ea3d3481c5a9c913795535765c6ccc684c2c0363dc76caac049751ffd2d2fb0df1872f6f50dd375b9aad67a702cc1920fea938637fac520ba280299b52734f5e85662af67e381457913442091c02e390b017207ec502aba217e4b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Life Record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏令营面试</title>
      <link href="//2024/07/07/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/"/>
      <url>//2024/07/07/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="951aaaeb503ab223966faf29b4a0a832d10646c276deb96940389b37a8d915d6">54e3726371269f5f4d16eecc3c6bcb42d185cacc6501b297ebb531def94b648a782469698b7eee9c4be4e8b63bc00fb0dd092588a7bc62532298e4ad870aae4b1fa7bde180b9f2fec2c70e58a56d8b0a8361919c35db03bdd4a4c5e3525db718ca00839ae692b722fa90c1ef8748526a3e2ffad3fec764b2854c4660dbf35007c7d7e292a9e403fca3c4b7fbcb69d27493f53844f753f94714bed5cdab07febc71150733369d3a5a3b16562185f93c3359f47ac5c7ef21164b00aafc520a16e42b2d648219f7757e9fb22716cf42b6f6739262c084c98ca974aabc84f30c25d2fdc0659ac5579776ec90c6ac8d8b43ad93c27eb2936f84b4b63779b65cfac5959100e3bb443e94c3e7067720cd5554406ffff5cea597a437adc41239064d0bbd75bab5f498fd4249725405efeb7e8999c42281eef3616c5d7c8d9a5fd097937e371d18b66d4d9dfccc88df8aa9121f67cb2e39423b59c471b961cef54cb6cc7d00c25a60993378765a0c77c8db51fa36e8d6d8d7d9e8ffe66e6d32634ec3812ca3e81cc5a1390bbb17d7e5e6d7341fcc1ead6f3d5fec8bc2970fa1c7039252f3047f69a1724965e9bf7f3425a539a6b9d8528d451eb07c1cd3aba4bb9c2c58012113a9e7ff0476edd7d2c79d3b87a782729507ce5e5a826c9c7d3950aa07c05301bdb4751150496d6c383b356df4b9e0acea240169c200dce0c207198664743a9c59a60f15bf77bb3723f3fbf3fbd1f2842a83026fea9967616cd6631778178274a962a120383443dc3d77c3463ca4a6dadfd28e9714922df3492ee83f825c397d4b3a60a170dcc061db649623852d7650323dd6af38a5542300e86e51d2fca77a8bf101af099bee0eaa63a648c195e363ca1540250d7c9f004bad03fd79576f148faa22b1b86f0759248dd53b5037fe6c4e85514c2838b99e9e4d36f7aca3fbdebeb5fef78584e78501dac8bffd866f55acd9d453fcd49e9954987393243ddfb52a7d4d3e6cf0dd2dc1db995c2bff97c69ea1d7e21fff96371f8a04a06110ba8b7dd1ea643aef02afaebfb06fcc76d4fa2c84563bc0177a3bf76a4e8dfe7b5869adc9c19c48cbd76f169ac3579394a4acb3b7cd6dae140e142e34238b358db809a2b47167b79e637b426874c0899e686faef4fb5a0a72b2401397844b60c3255086ee851328df58e2a4252e7106b31ef034ca1531e42765f703203965dfddad9b4c01292eea5fe569830d989d14e45d945e4bbf3012abce8afed2ca6d2ae32be708d49d3f159ae3cce64ced342e8510ae0e58babd9e121775c0230e51d27ec5876dd9e5f00bf257dafde600353dc92e3af608d7f063a93202db06cd8437849f07d0a2f6f7b680003c627619ee5d2567c69bb458ead14465c79cea0a3648da4de9cd83acc67b891ebe29745167a6cda61abce21ea55d76ec88f35567ae6a62e1ccaacae3c6f9bd3d8541866034ec82727459b0ed1e185266fb95a96a3a25498e80a730e75c5c3bf01109a02897228a94af8c2acd77df00043c32a7580a95aa9384abc162f2e5dd645bf7c4f5ef3da1f5828a331af4d73c153130902d2a39e1197584851234959d47a5af31b04b30bf1a60da81e3c73109769970dc117b2ffe43347f330ce28ef0a159ec7744536b110750ae79a0177943435261cb780ddd332e9c85f8cf5ce333d563489d13143cb6691d441688740f25ac718bb9099aa8f2850aa9b13ab9582c42f75d273503753b377b922bb197aedee5347cd001ae707ed8a7e26ae8f416edd12c077169743ca4d24c1f9f67231e51e9d64d6d861e2f44ae5a6047ac8f25f8390a0a1ba0937e21fe5e01c9227ab3591c08bb8e99ff2952bbbae7c46ce844313f8c1c9d08950719b8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Life Record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PGP实现</title>
      <link href="//2024/06/30/PGP%E5%AE%9E%E7%8E%B0/"/>
      <url>//2024/06/30/PGP%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>请转至<a href="http://t.csdnimg.cn/gLlHS">http://t.csdnimg.cn/gLlHS</a> ！</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="//2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/"/>
      <url>//2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ul><li>在某段时间，若对网络中某一资源的需要超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况叫做拥塞（congestion）。<ul><li>在计算机网络中的链路容量（即带宽）、交换节点中的缓存和处理机等，都是网络的资源。</li></ul></li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随负荷的增大而下降。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/1.png"></li><li>TCP的四种拥塞控制算法：慢开始（slow start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）。</li></ul><h3 id="慢开始、拥塞避免"><a href="#慢开始、拥塞避免" class="headerlink" title="慢开始、拥塞避免"></a>慢开始、拥塞避免</h3><p><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/2.png"></p><ul><li>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值<strong>取决于网络的拥塞程度</strong>，并且<strong>动态变化</strong>。<ul><li>拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就在增大一些；但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生重传）。</li></ul></li><li>发送方将拥塞窗口作为发送窗口，即<strong>swnd &#x3D; cwnd</strong>。</li><li>维护一个慢开始门限<strong>ssthresh</strong>的状态变量：<ul><li>当cwnd &lt; ssthresh时，<strong>使用慢开始算法，每收到一个报文段的确认cwnd加1</strong>；</li><li>当cwnd &gt; ssthtesh时，停止使用慢开始算法而<strong>改用拥塞避免算法，每经过一个往返时延cwnd加1；</strong></li><li>当cwnd &#x3D; ssthres时，既可以使用慢开始算法，也可以使用拥塞避免算法。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/3.png"></li></ul></li><li>“慢开始”是指一开始向网络中注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；</li><li>“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ul><li>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法（TCP Tahoe版本）。</li><li>1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复（TCP Reno版本）。<ul><li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。<ul><li>这将导致发送方超时重传，并误认为网络发生了拥塞；</li><li>发送方错误地启动慢开始算法，并把拥塞窗口cwnd又设置为最小值1，因而降低了传输效率。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/4.png"></li></ul></li></ul></li><li>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</li><li>所谓快重传，就是使发送方尽快进行重传，而不是等待重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>；</li><li>即使收到了失序（不是按照顺序来的）报文段也要立即发出对已收到报文段的<strong>重复确认</strong>；</li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段<strong>立即重传</strong>，而是不是等到该报文段的超时重传计时器超时在重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使得整个网络的吞吐量提高约20%。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/5.png"></li></ul></li></ul><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><ul><li>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而是<strong>执行快恢复算法</strong>。令ssthresh &#x3D; cwnd &#x3D; cwnd&#x2F;2。</li><li>也有的快恢复实现是把恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3；<ul><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li><li>可见现在网络中你不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。<br><img src="/2024/06/28/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/6.png"></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="//2024/05/22/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>//2024/05/22/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git分支-分支简介-2024-5-24"><a href="#Git分支-分支简介-2024-5-24" class="headerlink" title="Git分支-分支简介(2024-5-24)"></a>Git分支-分支简介(2024-5-24)</h1><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程–常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。<br>有人把Git的分支模型称为它的“必杀技特性”，也正因为这一特性，使得Git从众多版本控制系统中脱颖而出。为何Git的分支模型如此出众呢？Git处理分支的方式可谓是难以执行的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其他版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>为了真正理解Git处理分支的方式，我们需要回顾以下Git是如何保存数据的。<br>Git保存的不是文件的变化或者差异，而是一系列不同时刻的快照。<br>在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以很自然的想到–该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象还没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。<br>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和（使用SHA-1哈希算法），然后会把当前版本的文件快照保存到Git仓库中（Git使用blob对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &quot;The initial commit of my project&quot;</span><br></pre></td></tr></table></figure><p>当使用<code>git commit</code>进行提交操作时，Git会先计算每一个子目录（本目录中只有项目根目录）的校验和，然后在Git仓库中将这些校验和保存为树对象。</p><h1 id="Git分支-远程分支-2024-5-22"><a href="#Git分支-远程分支-2024-5-22" class="headerlink" title="Git分支-远程分支(2024-5-22)"></a>Git分支-远程分支(2024-5-22)</h1><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用时对远程仓库的引用（指针），包括分支、标签等等。你可以通过 <code>git ls-remote &lt;remote&gt;</code>来显示地获取远程引用的完整列表，或者通过<code>git remote show &lt;remote&gt;</code>来获取远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。<br>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信，Git就会为你移动它们以精确反应远程仓库的状态。请将它们看做书签，这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。<del>休息，明天再写</del><br><strong>（2024-5-23）</strong><br>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名。例如，如果你想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态，你可以查看<code>&lt;origin&gt;/&lt;branch&gt;</code>分支。你与同是合作解决一个问题并且她们推送了一个<code>iss53</code>分支，你可能有自己的本地<code>iss53</code>分支，然而在服务器上的分支会以<code>origin/iss53</code>来表示。<br>这可能有一点难以理解，让我们来看一个例子。假如你的网络里有一个在<code>git.ourcompany.com</code>的Git服务器。如果你从这里克隆，Git的<code>clone</code>命令会为你自动将其命名为<code>ogigin</code>，拉去它的所有数据，创建一个指向它的<code>master</code>分支，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与origin的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。<br><strong>Note</strong>:<br>“origin” 并无特殊含义<br>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/1.png"><br>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/2.png"><br>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/3.png"><br>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add teamone git://git.team1.ourcompany.com</code> 命令添加一个新的远程仓库引用到当前的项目，将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/4.png"><br>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。<br><img src="/2024/05/22/Git%E5%AD%A6%E4%B9%A0/5.png"></p><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>， 那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支。” 你也可以运行 <code>git push origin serverfix:serverfix</code>， 它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。<br><strong>Note</strong><br><em>如何避免每次输入密码?</em><br>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure><p>现在，本地分支  <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:<br>具体来说，<code>git branch -u</code>（或 <code>--set-upstream-to</code>）命令用于将本地分支配置为跟踪一个特定的远程分支。这样，你在进行操作时（例如拉取或推送），Git 知道应该与哪个远程分支进行交互。  </p><p>举个例子：命令 $ <code>git branch -u origin/serverfix</code> 的含义如下：<br>该命令将本地 serverfix 分支设置为跟踪远程仓库 origin 上的 serverfix 分支。当你在 <code>serverfix</code> 分支上运行 <code>git pull</code> 或 <code>git push</code> 时，不需要再指定远程分支，Git 会默认与 <code>origin/serverfix</code> 进行交互。</p><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的<code> server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<br><code>$ git fetch --all; git branch -vv</code></p><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 <strong>如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</strong></p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。(完)</p>]]></content>
      
      
      <categories>
          
          <category> Necessary Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU Make学习笔记</title>
      <link href="//2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
      <url>//2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明Makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p><ol><li><p>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</p></li><li><p>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</p></li><li><p>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</p></li></ol><p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p><h1 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h1><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    recipe</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>target</strong><br>可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p><p><strong>prerequisites</strong><br>生成该target所依赖的文件和&#x2F;或target。</p><p><strong>recipe</strong><br>该target要执行的命令（任意的shell命令）。</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prerequisites中如果有一个以上的文件比target文件要新的话,recipe所定义的命令就会被执行。</span><br></pre></td></tr></table></figure><p>这就是makefile的规则，也就是makefile中最核心的内容。</p><p>说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile 的主线和核心，但要写好一个makefile还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。:)</p><h1 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h1><p>正如前面所说，如果一个工程有3个头文件和8个C文件，为了完成前面所述的那三个规则，我们的makefile 应该是下面的这个样子的。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>反斜杠（ <code>\</code> ）是换行符的意思。这样比较便于makefile的阅读。我们可以把这个内容保存在名字为“makefile”或“Makefile”的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件edit。如果要删除可执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就可以了。</p><p>在这个makefile中，目标文件（target）包含：可执行文件edit和中间目标文件（ <code>*.o</code> ），依赖文件（prerequisites）就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code> 文件又是可执行文件 edit 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的recipe行定义了如何生成目标文件的操作系统命令，一定要以一个 <code>Tab</code> 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><p>这里要说明一点的是， <code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像C语言中的label一样，其冒号后什么也没有，那么，<code>make</code>就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h1 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h1><p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，</p><ol><li><p><code>make</code>会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p></li><li><p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</p></li><li><p>如果<code>edit</code>文件不存在，或是<code>edit</code>所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</p></li><li><p>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么<code>make</code>会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</p></li><li><p>当然，你的C文件和头文件是存在的啦，于是<code>make</code>会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成<code>make</code>的终极任务，也就是可执行文件 <code>edit</code> 了。</p></li></ol><p>这就是整个<code>make</code>的依赖性，<code>make</code>会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么<code>make</code>就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，<code>make</code>根本不理。<code>make</code>只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有的目标文件，以便重编译。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。</p><p>而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。</p><h1 id="又一个示例（2024-5-20）"><a href="#又一个示例（2024-5-20）" class="headerlink" title="又一个示例（2024-5-20）"></a>又一个示例（2024-5-20）</h1><p><del>（爆笑）今天520，又是羡慕别人的一天。只有我这个…</del><br>有三个cpp文件，一个头文件。目录层级如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── functional.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">└── printhello.cpp</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure><p>main.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printhello</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;This is main:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The factorial of 5 is:&quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>factorial.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printhello.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functional.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>functional.h如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNCTIONAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNCTIONAL_H</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FUNCTIONAL_H</span></span></span><br></pre></td></tr></table></figure><p>如果不适用make工具进行编译，那么只需在命令行执行<code> g++ main.cpp factorial.cpp printhello.cpp -o main</code>一次性生成可执行文件。但是对于一个大项目来说，源文件和头文件往往百十个，每次编辑文件之后，需要执行很长的命令很费时，因此使用Makefile文件协助编译。</p><h2 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h2><p>只是简单的将命令写到Makefile文件里面，并没有进行简化。如果需要增加cpp文件，则需手动在Makefile文件里面修改。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 1</span></span><br><span class="line"> hello: main.cpp factorial.cpp printhello.cpp </span><br><span class="line">g++ -o hello main.cpp factorial.cpp printhello.cpp</span><br></pre></td></tr></table></figure><h2 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h2><p>这个版本才是真正的Makefile文件。利用依赖关系书写。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o </span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure><h2 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h2><p>相比于版本2，将编译参数单独拿出作为一个变量CXXFLAGS,使用<code>$@</code>代替目标文件，使用<code>$^</code>代替所有的依赖文件，使用<code>$&lt;</code>代理第一个依赖文件。<br>加入了clean目标，清空中间文件（所有的.o文件）和目标文件。<code>.PYTHON: clean</code>作用是避免和名字叫做clean的文件产生歧义，加入这行代码，检测到.PYTHON(伪目标)不存在，去找clean依赖，clean依赖不存在，执行<code>rm -f *.o $(TARGET)</code>命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o </span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h2><p>较于版本3，不在一个一个书写所有的依赖文件，而是利用wildcard和patsubst函数生成所有的依赖文件（.o文件）。这对庞大项目很有用处。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ##VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span> </span><br><span class="line"><span class="comment">#　$(wildcard &lt;PATTERN...&gt;)</span></span><br><span class="line"><span class="comment"># 返回make工作下的所有.cpp以及.c文件  </span></span><br><span class="line"><span class="comment"># $(wildcard *.cpp *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"><span class="comment"># $(patsubst  &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把字符串“x.c.c bar.c”符合模式%.c的单词替换成%.o，返回“x.c.o bar.o”。</span></span><br><span class="line"><span class="comment"># $(patsubst %.c,%.o,x.c.c bar.c)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 使用 $^ 表示所有的依赖文件，使用 $@ 表示目标文件名。</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖文件，使用 $@ 表示目标文件。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>第一次make：写好所有文件和Makefile文件，执行make，对所有文件编译链接等等，然后生成可执行文件。<br>第二次make: 第一次make之后没有对源文件做任何变化，因此显示已经是最新的。<br>第三次make：对factorial.cpp文件编辑之后，然后执行make。由于只改动了factorial.cpp文件，<strong>只对它单独进行编译</strong>，然后链接生成可执行文件。这是make的优势所在，只对改变的cpp文件编译，对引用修改的.h头文件的cpp文件进行编译。<br>make clean:删除所有.o和目标文件。<br><img src="/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/1.png"><br><img src="/2024/05/19/make%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Necessary Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GUN Make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WORD学习笔记</title>
      <link href="//2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>//2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="S01入门-2024-04-10"><a href="#S01入门-2024-04-10" class="headerlink" title="S01入门(2024.04.10)"></a>S01入门(2024.04.10)</h1><h2 id="1、操作名词："><a href="#1、操作名词：" class="headerlink" title="1、操作名词："></a>1、操作名词：</h2><p> 选项卡，功能组，启动器，快捷工具栏，状态栏（视图状态），折叠（功能，页眉页脚）。</p><h2 id="2、操作习惯："><a href="#2、操作习惯：" class="headerlink" title="2、操作习惯："></a>2、操作习惯：</h2><p>1、保存和命名，随时CTRL+ s；用时间来命名；  </p><p>2、建立标准编辑环境：显示编辑标记，标尺，导航窗格；    </p><p>3、鼠标与键盘手势 （shift连续选择，ctrl跳跃选择，alt矩形选择；快速跳到开头或结尾）。  </p><p>4、快捷键<br>CTRL+C复制;<br>CTRL+V粘贴；<br>CTRL+Z撤销；<br>CTRL+Y前进；<br>按住CTRL不连续选择；<br>按住SHIFT连续选择；<br>按住ALT矩形框选；<br>单击ALT进入快捷键窗格模式（表现为选项卡出现格子）；<br>CTRL+B加粗；<br>CTRL+I倾斜；<br>CTRL+[&#x2F;]缩小、放大选中字体；<br>CTRL+(FN)+HOME&#x2F;END置顶&#x2F;到底；<br>CRTL+A全选；<br>CRTL+E&#x2F;L&#x2F;R 居中，左对齐，右对齐 CTRL+H 查找和替换 CTRL+（鼠标滚轮）缩放界面。  </p><h1 id="S02-排版实操讲解-204-04-11"><a href="#S02-排版实操讲解-204-04-11" class="headerlink" title="S02 排版实操讲解(204.04.11)"></a>S02 排版实操讲解(204.04.11)</h1><h2 id="一、段落格式"><a href="#一、段落格式" class="headerlink" title="一、段落格式"></a>一、段落格式</h2><p>1.换行符：SHIFT+ENTER(换行不换段落)</p><p>2.与格式刷：复制字体格式，不选段落标记；</p><p>复制段落格式，光标停留在相应区域；</p><p>TIP：单击格式刷：使用一次，双击：总是启用，直到取消。</p><h2 id="二、文本布局（先全局再细节）"><a href="#二、文本布局（先全局再细节）" class="headerlink" title="二、文本布局（先全局再细节）"></a>二、文本布局（先全局再细节）</h2><p>1.字体：字体选项卡，分别设置中英文；</p><p>2.段落:<br>①段落缩进：左侧，右侧，首行；</p><p>标尺：上面的小三角&#x3D;首行缩进，下面的方块三角&#x3D;段落全体缩进。</p><p>②设置行距。</p><h1 id="S03合同排版和修订-2024-4-11"><a href="#S03合同排版和修订-2024-4-11" class="headerlink" title="S03合同排版和修订(2024-4-11)"></a>S03合同排版和修订(2024-4-11)</h1><h2 id="一、合同的要素"><a href="#一、合同的要素" class="headerlink" title="一、合同的要素"></a>一、合同的要素</h2><p><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png"></p><h2 id="二、合同的排版"><a href="#二、合同的排版" class="headerlink" title="二、合同的排版"></a>二、合同的排版</h2><p>①字体和字号的对比突出重点。调整行距，利用页面空间，防止视觉疲劳。</p><p>②表格（去除框线）可以让落款整洁。</p><p>③适当使用横线、框线等来提升排版。标尺排版也要常用。设置段前段后行距，区分内容。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png"></p><p>TIP：.doc是指一个旧版的WORD文档。.docx那就是新版的。兼容模式之下很多功能无法使用。必须要转换。</p><h2 id="三、（合同）审阅功能"><a href="#三、（合同）审阅功能" class="headerlink" title="三、（合同）审阅功能"></a>三、（合同）审阅功能</h2><p>1.修订功能：</p><p>在 审阅 窗格内，点亮 修订 按钮即可进入。这可以用于团队文档修改。</p><p>在这个状态下，Backspace将不会删除文本，而是会出现红色删除线。同时，添加的文本也会是红色。</p><p>如果你修改了某些东西，将会在文档右侧的栏目中标记，显示。</p><p>但是，如果你没有看到上述界面（有时可能只会显示红线），在 审阅 的 修订 按钮旁边会有对标记显示的选项。你可以按照审阅需要勾选。</p><p>2.批注功能：</p><p>同样在 审阅 窗格内，有 批注 选项，可以进行旁栏批注。</p><p>3.注意事项：批注和修订的编辑、接受以及拒绝。</p><p>你会发现修订和批注的内容无法用常规编辑方式进行修改。</p><p>对于修订，同样在 审阅 窗格下，只有 接受 和 拒绝 两个可选。接受代表修订的内容可以继续存在，拒绝则撤回修订的所有操作。</p><p>对于批注，可以答复或者删除。</p><p>另外，批注和未被接受的修订不会被打印。</p><p>TIP：如果你的队友很遗憾的不会使用审阅功能，你可以另存为你的原文档，随后把他改过的在 审阅 选项卡 内进行 比较 功能运行即可。</p><h2 id="P4·合同保护和管理"><a href="#P4·合同保护和管理" class="headerlink" title="P4·合同保护和管理"></a>P4·合同保护和管理</h2><h1 id="S04邮件合并功能-2024-4-15"><a href="#S04邮件合并功能-2024-4-15" class="headerlink" title="S04邮件合并功能(2024-4-15)"></a>S04邮件合并功能(2024-4-15)</h1><p><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png"><br>邮件-&gt;选择收件人-&gt;选择现有列表，导入Excel数据源；在正文中将&lt;姓名&gt;，&lt;面试成绩&gt;选中’插入合并域’替换；之后，编辑’收件人列表’可以进行筛选，最后’完成合并’。</p><h1 id="S05学长分享-2024-4-22"><a href="#S05学长分享-2024-4-22" class="headerlink" title="S05学长分享(2024-4-22)"></a>S05学长分享(2024-4-22)</h1><p>形策课一位17级学长分享。<br>1、读研的意义是什么，自己想干嘛；<br>2、不要做i人，尽可能开口去问；<br>3、找工作面试的时候看完全公司的介绍；<br>4、工作拼的可能是体力，不是智力；<br>5、工作和学校不一样，请假不是一样的，职场没有借口。</p><h1 id="S06表格、图片、文字-2024-5-11"><a href="#S06表格、图片、文字-2024-5-11" class="headerlink" title="S06表格、图片、文字(2024-5-11)"></a>S06表格、图片、文字(2024-5-11)</h1><h2 id="1、表格：财务计算、大写金额"><a href="#1、表格：财务计算、大写金额" class="headerlink" title="1、表格：财务计算、大写金额"></a>1、表格：财务计算、大写金额</h2><p>计算采：用公式，可像excel里面输入单元格范围。注意：单击表格之后，工具栏上会出现新的“布局”选项卡，再单击“公式”。不是原来的“布局”选项卡。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png"><br>大写：“插入”-&gt;“编号”，选择大写数字，输入数字即可转换为大写金额。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png"></p><h2 id="2、图片（压缩）"><a href="#2、图片（压缩）" class="headerlink" title="2、图片（压缩）"></a>2、图片（压缩）</h2><p>对于标书中大量图片另存为的时候，点击“工具”-&gt;“压缩图片”，选择分辨率。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png"></p><h2 id="3、标书制作"><a href="#3、标书制作" class="headerlink" title="3、标书制作"></a>3、标书制作</h2><p>太晚了，明天写。<br>2024-5-10更。</p><ol><li>编号习惯</li></ol><ul><li>阿拉伯数字后带原点</li><li>汉字数字后用顿号</li><li>带括号的序号和带圈序号，后面不加标点符号，且带括号的序号一般不超过10</li></ul><ol start="2"><li>标书文件格式<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%87%E4%B9%A6.png"><br>注意修改完之后：一级标题前通常要“段前分页”，附录前面也要“段前分页”。建议新建“样式”-&gt;“附件”，方便统一管理。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%99%84%E4%BB%B6%E6%A0%B7%E5%BC%8F.png"><br>使用通配符替换掉原有标题前的序号，应用格式要求中的多级列表编号。(?)-&gt;空，?、-&gt;空。(英文?,中文、)<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%87%E4%B9%A62.png"></li></ol><h1 id="S07表格辅助排版-表格疑难杂症-表格美化-三线表-2024-5-12"><a href="#S07表格辅助排版-表格疑难杂症-表格美化-三线表-2024-5-12" class="headerlink" title="S07表格辅助排版&#x2F;表格疑难杂症&#x2F;表格美化&#x2F;三线表(2024-5-12)"></a>S07表格辅助排版&#x2F;表格疑难杂症&#x2F;表格美化&#x2F;三线表(2024-5-12)</h1><h2 id="辅助排版："><a href="#辅助排版：" class="headerlink" title="辅助排版："></a>辅助排版：</h2><p>1、封面&#x2F;落款&#x2F;公文头：<br>卫生局文件<br>妇女联合会<br>2、用表格排版图片：固定列宽,tab键移动到下一个单元格，制作完后表格整体居中。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC1.png"></p><h2 id="表格疑难杂症："><a href="#表格疑难杂症：" class="headerlink" title="表格疑难杂症："></a>表格疑难杂症：</h2><p>1、表格超过页面，右侧文字看不见<br>    全选表格-&gt;布局-&gt;自动调整-&gt;根据窗口自动调整表格。原因是因为粘贴表格前后的宽度不一致。也可以调整布局-&gt;纸张大小,增大宽度。建议使用表格的自动调整。<br>2、表格底部文字被遮挡<br>    原因是因为表格行高的问题。<br>调整方法：表格属性-&gt;指定高度-&gt;最小值。最小值情况下表格高度会保证最少容纳所有文字。<br>3、长表格跨页断行（明明是一个表格，却没放在一个页面）<br>    调整方法：表格属性-&gt;行-&gt;允许跨页断行。<br>4、如何去除表格后面的空白页<br>    原因：新建word换行的段落标记因为被表格占据，导致第一个页面放不下该段落标记，所以段落标记跑到了第二页。<br>    调整方法：i.行高改为小值，如1磅。ii.将页边距的上下调小，使得放下段落标记。</p><h2 id="表格美化："><a href="#表格美化：" class="headerlink" title="表格美化："></a>表格美化：</h2><p>1、自定义：居中对齐，留白，弱化表格的束缚感，清晰整洁：边框采用浅色，如灰色；标题行应用底纹。<br>2、使用自带的样式。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC2.png"></p><h2 id="三线表："><a href="#三线表：" class="headerlink" title="三线表："></a>三线表：</h2><p>边框取消；标题行：上边框粗，下边框细；汇总行：下边框粗；创建新的表格样式“三线表”，每次插入表格就可以直接应用“三线表”。(这种方法似乎不可行)<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC3.png"><br>另一种办法：<br>切换到【插入】选项卡，在【表格】组中，单击【表格】的下三角按钮，在弹出的列表中将鼠标移动至【快速表格】按钮，弹出下一级菜单，在此，点击最下方的【将所选内容保存到快速表格库】按钮。弹出【新建构建基块】对话框，设置名称，并简单说明表格作用，单击【确定】按钮，即可完成表格添加到快速表格库中。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC4.png"></p><h1 id="S08查找替换功能-2024-5-13"><a href="#S08查找替换功能-2024-5-13" class="headerlink" title="S08查找替换功能(2024-5-13)"></a>S08查找替换功能(2024-5-13)</h1><h2 id="设置填空题"><a href="#设置填空题" class="headerlink" title="设置填空题"></a>设置填空题</h2><p>ctrl选择任意位置几处文字，字体颜色设置为红色。ctrl+h替换，将“红色”的字体替换为“下划线”，字体设置为白色，下划线颜色设置为黑色。设置完之后效果。<br><img src="/2024/05/10/WORD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/S08-1.png"></p><h2 id="批量删除图片（嵌入型）"><a href="#批量删除图片（嵌入型）" class="headerlink" title="批量删除图片（嵌入型）"></a>批量删除图片（嵌入型）</h2><p>替换选项里面，特殊格式图片(^g)替换为空。可在选项卡里面设置插入图片类型默认为“嵌入型”。删除之后若出现多个空白行，也就是多个段落标记，“替换”选项里面将多个段落标记替换为一个，删除多余空白行。<br>此外，替换选项还有多种功能。如将特定文字应用为标题样式：查找【四号字体、加粗】，替换为【样式、标题一】。</p>]]></content>
      
      
      <categories>
          
          <category> Necessary Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WORD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序、快速排序、合并排序</title>
      <link href="//2024/05/09/%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/"/>
      <url>//2024/05/09/%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔(shell)排序是插入排序的一种。也称<strong>缩小增量排序</strong>，是直接插入排序的一种更高效的改进版本。希尔排序是非稳定排序。希尔排序是按照记录下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量减少，每组包含的关键词增多，当增量减少至1时，所有元素被分为1组，算法结束。<br>我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。而如上面这样分完组后，就各自排序的方法达不到我们的要求。因此，我们需要采取<strong>跳跃分割</strong>的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br><img src="/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort</span><span class="params">(E A[],<span class="type">int</span> n,<span class="type">int</span> incr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = incr;i &lt; n;i += incr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i;(j &gt; incr) &amp;&amp; (A[j] &lt; A[j-incr]);j -= incr)</span><br><span class="line">      <span class="built_in">swap</span>(A,j,j - incr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>;i &gt; <span class="number">2</span>;i /= <span class="number">2</span>)<span class="comment">//增量从n/2开始，直到增量为2，增量为1的单独处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">      <span class="built_in">inssort</span>&lt;E&gt;(A[j],n-j,j);<span class="comment">//从j处开始,n-j处结束</span></span><br><span class="line">  <span class="built_in">inssort</span>&lt;E,Comp&gt;(A,n,<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>一趟快速排序思想</strong><br>1、目标：找一个记录，以它的关键字作为<strong>枢轴</strong>，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。致使一趟排序之后，记录的无序序列A[s..t]将分割成两部分：<br>A[s..i-1]和A[i+1..t]，且A[j].key(左边)≤ A[i].key(枢轴) ≤ A[k].key(右边)<br>2、首先对无序的记录序列进行“一次划分”，之后分别对分割所得的两个子序列“递归”进行快速排序。<br><img src="/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png" alt="快排1"><br>3、一趟快速排序的过程<br>a.  首先选定轴，交换轴与最后一个元素；(最后要交换回来)<br>b. 设定l指针指向第一个元素前的位置，r指向最后元素；<br>c. 先移动l，遇到比轴大则停止；再移动r，遇到比轴小停止，交换l和r所指元素。<br>d. 持续执行上一步，直到l和r相遇；<br>e. 将最后一个元素和停止时l(r)位置的元素交换。<br><img src="/images/%E5%BF%AB%E6%8E%922.png"><br>4、代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findpivot</span><span class="params">(E A[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (i+j)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="comment">/*1、内联函数，编译时直接替换成函数体的内容，避免对栈空间的重复消耗;</span></span><br><span class="line"><span class="comment">2、返回枢轴的下标；取中间、第一个、最后一个都可以。*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(E A[],<span class="type">int</span> l,<span class="type">int</span> r,E&amp; pivot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(A[++l] &lt; pivot);<span class="comment">//当左边l所指元素小于枢轴，一直向右寻找，直到大于枢轴，停止</span></span><br><span class="line">    <span class="keyword">while</span>((l &lt; r) &amp;&amp; A[--r] &gt; pivot);</span><br><span class="line">    <span class="built_in">swap</span>(A,l,r);</span><br><span class="line">  &#125;<span class="keyword">while</span>(l &lt; r)</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(E A[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="comment">//i代表左指针，j代表右指针</span></span><br><span class="line">  <span class="keyword">if</span>(j &lt;= i)<span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> pivotindex = <span class="built_in">findpivot</span>(A,i,j);</span><br><span class="line">  <span class="comment">/*这里之所以调用函数，是为了后续的可扩展性和修改：</span></span><br><span class="line"><span class="comment">  假如要取第一个元素为枢轴，直接修改findpivot函数即可，</span></span><br><span class="line"><span class="comment">  不用修改qsort函数主体*/</span></span><br><span class="line">  <span class="built_in">swap</span>(A,pivotindex,j);<span class="comment">//把枢轴放到最后</span></span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">partition</span>&lt;E&gt;(A,i<span class="number">-1</span>,j,A[j]);<span class="comment">//k为左右指针相遇的地方</span></span><br><span class="line">  <span class="built_in">swap</span>(A,k,j);<span class="comment">//把枢轴交换回来</span></span><br><span class="line">  <span class="comment">/*把轴交换回位置k，意味着轴把k前后的数据一分为二*/</span></span><br><span class="line">  <span class="built_in">qsort</span>&lt;E&gt;(A,i,k<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">qsort</span>&lt;E&gt;(A,k+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、时间复杂度<br>假设一次划分所得枢轴位置 i&#x3D;k，则对n个记录进行快排所需时间：<br>　　　　T(n) &#x3D; Tpass(n) + T(k-I) + T(n-k),<br>其中 Tpass(n)为对 n 个记录进行一次划分所需时间。<br>若待排序列中记录的关键字是随机分布的，则 k 取 1 至 n 中任意一值的可能性相同。<br>由此可得快速排序所需时间的平均值为：<br><img src="/images/%E5%BF%AB%E6%8E%923.png"><br><strong>结论</strong>：<br>快速排序的时间复杂度为O(nlogn)。<br>若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n^2)。</p><h3 id="合并（归并）排序"><a href="#合并（归并）排序" class="headerlink" title="合并（归并）排序"></a>合并（归并）排序</h3><p>算法思想：<br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F1.png"><br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F2.png"><br>例如：<br><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F3.png"><br>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;tyepname E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(E A[],E temp[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*合并排序算法虽说也是O(nlogn)，但是使用了临时数组temp，  </span></span><br><span class="line"><span class="comment">  因此STL中的sort()函数一般采用快排(当然还有其他算法的加速)，  </span></span><br><span class="line"><span class="comment">  而非合并排序*/</span></span><br><span class="line">  <span class="keyword">if</span>(left == right) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E&gt;(A,temp,left,mid);</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E&gt;(A,temp,mid+<span class="number">1</span>,right);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = left;i &lt;= right;i ++)<span class="comment">//将原数组内容复制到临时数组</span></span><br><span class="line">    temp[i] = A[i];</span><br><span class="line">  <span class="type">int</span> i1 = left,i2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> curr = left; curr &lt;= right;curr ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == mid + <span class="number">1</span>)<span class="comment">//如果左边的一半已经到头，直接把右边剩下的复制给原数组</span></span><br><span class="line">      A[curr] = temp[i2++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt; right)</span><br><span class="line">      A[curr] = temp[i1++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp[i1] &lt; temp[i2])<span class="comment">//取小的赋给原数组</span></span><br><span class="line">      A[curr] = temp[i1++];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      A[curr] = temp[i2++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)<br>时间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种O(n^2)的排序算法</title>
      <link href="//2024/05/08/%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>//2024/05/08/%E4%B8%89%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>排序算法的稳定性</strong>：所有相等的数经过某种排序方法后，仍能保持它们在排序前的相对次序，我们称这种排序算法是稳定的。反之，就是非稳定算法。<br><strong>内排序</strong>：在排序过程中，所有需要排序的数都在内存，并在内存中调整它们的顺序，称为内排序。<br><strong>外排序</strong>：在排序过程中，只有部分数被调入内存，并借助内存调整数在外存中的相对顺序，称为外排序。  </p><h5 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h5><p>分三个步骤：</p><ul><li>在在A[1..i-1]中查找A[i]的插入位置，A[1..j].key &lt;&#x3D; A[i].key &lt; A[j+1..i-1].key;</li><li>将A[j+1..i-1]中的所有记录均后移一个位置;</li><li>将A[i]插入(复制)到A[j+1]的位置上。<br><img src="/images/insort.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i;(j&gt;<span class="number">0</span>) &amp;&amp; (Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]);j --))<span class="comment">//如果A[j]&gt;A[j-1],交换</span></span><br><span class="line">      <span class="built_in">swap</span>(A[j],A[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h5><p><img src="/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//标记此次冒泡过程中是否交换了元素，没有的话说明元素已经有序，终止</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = n - <span class="number">1</span>;j &gt; i;j --)<span class="comment">//从后向前冒泡，从前往后也一样</span></span><br><span class="line">      <span class="keyword">if</span>(Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]))<span class="comment">//如果A[j]&gt;A[j-1]</span></span><br><span class="line">      &#123;<span class="built_in">swap</span>(A,j,j<span class="number">-1</span>);flag = True;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h5><p><img src="/images/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png"><br>假设当前下标为最小值的下标，向后遍历，一直更新最小值的下标，找到尽头，交换最小值和当前值。更新当前下标，持续上述，直至当前下标为最后一个元素下标。<br>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(T arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j,min;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">    min = i;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; len;j ++)</span><br><span class="line">      <span class="keyword">if</span>(arr[min] &gt; arr[j])</span><br><span class="line">        min = j;</span><br><span class="line">      <span class="built_in">swap</span>(arr[i],arr[min]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六级作文急救包，拒绝jpg拥抱png</title>
      <link href="//2023/12/11/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87%E8%80%83%E5%89%8D%E6%80%A5%E6%95%91%E5%8C%85%EF%BC%8C%E6%8B%92%E7%BB%9Djpg%E6%8B%A5%E6%8A%B1png/"/>
      <url>//2023/12/11/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87%E8%80%83%E5%89%8D%E6%80%A5%E6%95%91%E5%8C%85%EF%BC%8C%E6%8B%92%E7%BB%9Djpg%E6%8B%A5%E6%8A%B1png/</url>
      
        <content type="html"><![CDATA[<h3 id="一、议论文"><a href="#一、议论文" class="headerlink" title="一、议论文"></a>一、议论文</h3><p>1.问题解决：how</p><p>2.现象解释：what why</p><p>3.观点选择</p><h4 id="问题-现象解决类"><a href="#问题-现象解决类" class="headerlink" title="问题&#x2F;现象解决类"></a>问题&#x2F;现象解决类</h4><p>例子2018上半年——问题&#x2F;现象解决类</p><p>第一段</p><p>With the rapid development of <u>……</u><br>（education，society，technology，culture，economy，medical service)_____,it is of great necessity  for to<u>…….</u>.<br>The following solutions can account for this phenomenon&#x2F;issue.</p><p>第二段</p><p>论点1 First and foremost ,there is no doubt that _____.</p><p>论据1 Based on a most recent survey ,it is revealed that( a majority pf successful social admit that they prefer ____)</p><p>论点2 Furthermore， it is obvious that it is beneficial for( students to ______)</p><p>论据2<br>Where there is a will ，there is a way.(改编谚语)</p><p>如where there are friends ，there is communication.Therefore，our speaking ability can be improved.</p><p>论点3 Last but not least, no one can deny that it is high time that _____.</p><p>论据3 Only in this way, can we ______.</p><p>第三段</p><p>重申观点：In a word , it is clear that we should promote<u>……</u> If we try our utmost to<u>……</u>.the future of our life will be both promising and rosy.</p><h4 id="观点选择"><a href="#观点选择" class="headerlink" title="观点选择"></a>观点选择</h4><p>第一段：阐述问题，（列出不同观点，做出选择）过渡句3-4句</p><p>With the rapid development of ((economy&#x2F;culture&#x2F;society&#x2F;technology&#x2F;medical&#x2F;service&#x2F;education),nowadays youngsters have different options upon graduation.Some thinks that to find a job somewhere is beneficial, while others think to start a business of your own is a better.Personally, I prefer the former&#x2F;latter.The following reasons can account for my preference.</p><p>第二段</p><p>论点 1 First and foremost ,there is no doubt that _____.</p><p>论据1 Based on a most recent survey ,it is revealed that( a majority pf successful social admit that they prefer ____)</p><p>论点2 Furthermore， it is obvious that it is beneficial for( students to ______)</p><p>论据2 </p><p>Where there is a will ，there is a way.(改编谚语)</p><p>如where there are friends ，there is communication。Therefore，our speaking ability can be improved.</p><p>论点3 Last but not least, no one can deny that it is high time that _________________________(though )</p><p>论据3 Only in this way, can we ______.</p><p>第三段：重申观点+提出期望</p><p>In a word, A is better &#x2F; more suitable than B. If we spare no efforts to ____ the future of our life(与主题相关的)will be both rosy and promising</p><h4 id="现象解释（图画类作文"><a href="#现象解释（图画类作文" class="headerlink" title="现象解释（图画类作文)"></a>现象解释（图画类作文)</h4><p>第一段：3句话（阐述背景+提出观点+过渡句)</p><p>With the rapid of society&#x2F;culture&#x2F;economy&#x2F;technology&#x2F;education&#x2F;medical service,there is an increasing number of citizens moving from suburbs to the urban area.There are a large number of challenges of living in big cities .Followings are some of them.</p><p>第二段：</p><p>第二个段落：活动目的+三个具体事件+三句补足+以时间顺序串联</p><p>（6句话）论点1论据1，论点2论据2，论点3论据3，一个论点紧跟一个论据</p><p>论点 1.First and foremost ,there is no doubt that _____</p><p>论据一Based on a most recent survey ,it is revealed that a majority pf successful social elites admit that they 编一些数据</p><p>论点2 Furthermore， it is obvious that( it is beneficial for students to ______)</p><p>论据2 万能谚语——改编谚语</p><p>Where there is a will ，there is a way</p><p>如where there are friends ，there is communication。Therefore，our speaking ability can be improved.</p><p>论点3 Last but not least, no one can deny that it is high time that _____</p><p>论据3 only in this way, can we ______</p><p>第三段：重申观点，提出期望</p><p>In a word , it is of great necessity for the residents to face the challenges. If we spare no efforts to <u>……</u>,the future of<u>……</u> will be both promising and rosy.</p><h3 id="二、应用文"><a href="#二、应用文" class="headerlink" title="二、应用文"></a>二、应用文</h3><p>notice，advertisement，letter，news report，invitation，announcement，speech</p><h4 id="应用文（新闻报导）"><a href="#应用文（新闻报导）" class="headerlink" title="应用文（新闻报导）"></a>应用文（新闻报导）</h4><p>文体特征——客观，第三人称（they，he，she，student union）</p><p>过去式（一般过去时）过去进行时（事件的背景）</p><p>新闻的结构（先出结果<br>+再出细节+意义）</p><p>三个段落：</p><p>第一段：时间，地点，参与者，事件本身，事件结果</p><p>On December First, Monday ,the Student Union organized a meaningful activity to visit the local farm, in which 300 volunteers actively participated.It turns out to be a great success.</p><p>第二段：三个具体时间+三句补足</p><p>This activity was aimed at cultivating the practical ability of students by <u>……</u>visiting the farmland and helping the peasants with hard labours. In the early morning just after the arrival of  students , the students watered the crops in the field for farmers.(事件一)+when asked about those volunteers’ feelings about such an experience , all of them responded with a smile, saying “what a wonderful practice and i really appreciate this experience, for it makes me learn to care more for others in need.(use my knowledge in practice)(万能补足语一)</p><p>After the lunch, the farmers held an experience sharing meeting ,in which the students answered various useful questions.(事件二)Some students showed how to use technology to improve the productivity(补足语二).In the evening， the students and the farmers enjoyed a feast together , which was prepared by the students.（事件三）The peasants praised the cooking of students.（补足语三）</p><p>第三段：新闻的意义</p><p>this event&#x2F;activity turns out to be a beneficial event for both sides.The student union expressed that there will be more meaningful events in the future.(或者more efforts will be made to help farmers in the rural areas)</p><h3 id="比较固定的模板"><a href="#比较固定的模板" class="headerlink" title="比较固定的模板"></a>比较固定的模板</h3><p>第一个段落：（1-2句话）提出问题 ，（第三句话）过渡句；</p><p>第二个段落：（6句话）论点1论据1，论点2论据2，论点3论据3，一个论点紧跟一个论据；</p><p>第三个段落：（2句话）第一句话重申观点，第二句话提出期望。</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>凡尔登战役</title>
      <link href="//2023/12/03/%E5%87%A1%E5%B0%94%E7%99%BB%E6%88%98%E5%BD%B9/"/>
      <url>//2023/12/03/%E5%87%A1%E5%B0%94%E7%99%BB%E6%88%98%E5%BD%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>这样的战争绝无可能再重来一遍了，我们或许能再打一次马恩河。可是凡尔登， 不行。这种战争需要坚定的的信仰，  需要多年积攒下来的安全感，还需要各阶级之间紧密无间的关系，你必须拥有能够使你全心全意的情感来源，你必须记得圣诞节，记得皇太子和他未婚妻的明信片，还有瓦朗斯的小咖啡馆，柏林大街上的啤酒屋以及市政厅的婚礼，记得德比的赛马会，记得爷爷唇边的胡子。带着这些旧日的回忆，我从战争中活着回来。可是，那个美丽且安全的世界，都随着这一阵爆炸带过的狂风，在我面前炸的粉碎，化为乌有。————F.斯科特·菲茨杰拉德《夜色温柔》<br><img src="/images/%E6%97%A5%E8%90%BD%E8%A5%BF%E5%B1%B1.png" alt="日落西山"></p><p><a href="https://www.bilibili.com/video/BV1Mj411E7c2/?spm_id_from=333.337.search-card.all.click&vd_source=463e0e7bf27429516a814252436fdba5">凡尔登战役是如何毁掉一代法国人的？【一战的故事·1916】</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>凡尔登战役「Battle of Verdun &amp; La Bataille de Verdun」是第一次世界大战中破坏性最大，时间最长的战役。战事从1916年2月21日延续到12月19日，德、法两国投入100多个师兵力，军队死亡超过25万人，50多万人受伤。伤亡人数仅次于索姆河战役，被称为“凡尔登绞肉机”。  </p><p>1916年初，德意志帝国统帅部决定把战略重点西移，德军总参谋长埃里希·冯·法金汉将打击目标定在法国境内著名要塞凡尔登。凡尔登是英法军队战线的突出部，它像一颗伸出的利牙，对深入法国北部的德军侧翼形成严重威胁，德、法在这里曾有过多次交手，但德军皆未能夺取要塞。如果此次德军能一举夺取凡尔登，必将沉重打击法军士气。同时，占领了凡尔登，也就打通了德军迈向巴黎的通道，占领了巴黎，法国就不攻自灭了，剩下的英、俄两军就不足为惧了。  </p><p>凡尔登战役以法国的胜利告终，德国企图一举击败法国的战略目标再次遭受挫折，损失了巨大的人力和物力，又无法及时弥补。它标志着德国军事进攻的能力已从顶峰跌落，战争主动权逐渐转到协约国手里。</p><h2 id="战争背景"><a href="#战争背景" class="headerlink" title="战争背景"></a>战争背景</h2><p>1914年德国没有能取得迅速胜利，欧洲战场在西线形成胶着状态的堑壕战，交战双方谁都不能前进一步。  </p><p>1915年，德国的几次努力进攻都没有能够奏效。德国将军冯·法金汉认为如果对法国加强打击，迫使法军投入所有兵力，会使法国因消耗而亡。他选择了位于默兹高地上的凡尔登要塞作为主要进攻点，凡尔登是法国东北部的一座小城市，是德国通往巴黎的主要交通要道，有“巴黎钥匙”之称。可以使法国“流尽最后一滴血”。<br>1916年初，德军统帅部计划在东线进行防御，集中兵力对西线法军的凡尔登突出部实施突击，以牵制和消耗法军主力，迫使法国投降。受领进攻任务的部队是德国皇太子威廉指挥的第5集团军（辖7个军共17个师，1204门火炮，其中重型火炮683门，168架飞机；后增至50个师，约占西线德军总兵力的1&#x2F;2）。  </p><p>凡尔登是法国东北边境的战略据点、巴黎的东部门户，是法军整个战线的支撑点，法军统帅部也非常重视保卫这个战略要地。凡尔登筑垒地域正面宽达112公里，由法军第三集团军（由埃尔将军指挥，拥有11个师，632门火炮）防守。筑垒地域由四道防御阵地组成，全纵深15—18公里。其中三道是野战防御阵地。第四道防御阵地由凡尔登要塞的永备工事和两个堡垒地带构成。  </p><p>1916年1月开始，法金汉就悄悄结集部队准备攻击凡尔登，同时，德国明目张胆地向香贝尼增兵，做出要在香贝尼发动攻势的姿态。法军总司令霞飞果然上当了。自1914年德军无力攻克凡尔登而转移进攻方向之后，法国人就认为凡尔登要塞已经过时，霞飞在1915年即停止强化要塞。而此时德军向香贝尼移动的动作使霞飞异常警惕，他认为德军会向香贝尼进攻，然后从这里进军巴黎。</p><p>德国人正在继续往凡尔登方向悄悄结集兵力。随着结集迹象的渐渐明显和暴露，英法联军终于弄清了德军的真正意图。霞飞慌了神，火速下令向凡尔登增兵。1916年2月，德国皇太子亲率21万德军，向凡尔登发动了疯狂进攻。凡尔登的保卫力量比较虚弱，但由于气候条件不佳，德国的进攻推迟了，为法国调集援兵提供了时间，法国调集了两个师进入这个地区。<br><img src="/images/%E6%88%98%E4%BA%89%E5%9B%BE.webp" alt="凡尔登战役"></p><h2 id="兵力部署"><a href="#兵力部署" class="headerlink" title="兵力部署"></a>兵力部署</h2><p><strong>德军</strong><br>第7、第18、第3军（6个半师，879门火炮，其中重型火炮522门，202门迫击炮）在孔桑瓦至奥恩河15公里宽正面上实施主要突击，第5军掩护其左翼；第15军在奥恩河以南6公里处实施辅助突击，第6军在默兹河西岸采取牵制行动。在主突方向上，法国只有2个师，德军步兵比法军步兵正多两倍，炮兵多3.5倍，火炮密度达到每公里正面50—110门。为达成战役突然性，德军于同年1月在西线实施一系列佯动。<br><strong>法军</strong><br>法军凡尔登筑垒地域横跨默兹河两岸，正面宽112公里，纵深15～18公里；有四道防御阵地，前三道为野战防御阵地，第4道是由要塞永备工事和两个筑垒地带构成的坚固阵地，居高临下，易守难攻。法第3集团军（辖11个师，630余门火炮，由F.埃尔将军指挥；后增至69个师，约占法军总兵力的2&#x2F;3）5个师防守凡尔登以北地区，3个师防守凡尔登以东和东南地区，另3个师作为预备队配置在凡尔登以南默兹河西岸地区。<br><img src="/images/%E9%A9%BB%E5%AE%88%E5%9C%A8%E5%87%A1%E5%B0%94%E7%99%BB%E7%9A%84%E4%B8%80%E5%90%8D%E6%B3%95%E5%9B%BD%E5%A3%AB%E5%85%B5.jpg" alt="驻守在凡尔登的一名法国士兵"></p><h2 id="战役过程"><a href="#战役过程" class="headerlink" title="战役过程"></a>战役过程</h2><p><strong>炮火准备</strong><br>1916年2月21日，为了不暴露主要突击方向，德国军队用1,200门大炮对40公里的战线进行了8个半小时的集中轰击，发射了一百万发炮弹，然后用三个军（第三、第七、第十八军）的兵力进攻，先头部队用火焰喷射器扫清战壕，到23日，德国军队已经前进了将近5公里，法国军队被迫后撤。  </p><p>德军开始炮火准备。为隐蔽主突方向，德军炮兵在宽40公里的正面上同时实施炮击，航空兵首次对法军阵地实施轰炸，摧毁部分防御阵地，并杀伤大量有生力量。16时45分，德军步兵发起冲击，当日占领第一道防御阵地。在以后四天中，又先后攻占第二、第三道防御阵地，向前推进5公里，占领重要支撑点杜奥蒙堡。步兵进攻时采用纵深战斗队形以散兵线分波次推进，最前面为强击群。</p><p>法军统帅部任命第2集团军司令贝当为凡尔登前线指挥官（5月1日起由罗贝尔·尼维尔继任），并调集一切可以动用的部队，决心在凡尔登地区与德军决战。26日，贝当下令夺回杜奥蒙堡。法军经四天激战，损失惨重，未果。自2月27日起，法军利用唯一与后方保持联系的巴勒迪克—凡尔登公路（又称“圣路”），源源不断地向凡尔登调运部队和物资，一周内组织3900辆卡车，运送人员19万、物资2.5万吨。这是战争史上首次大规模汽车运输。</p><p>法军大批援军及时投入战斗，加强了纵深防御，对战役进程产生了重大影响。至月底，德军弹药消耗很大，且战略预备队未及时赶到，攻击力锐减，从而丧失了突破法军防线的时机。<br><img src="/images/%E8%A2%AB%E8%BD%B0%E7%82%B8%E5%90%8E%E7%9A%84%E5%87%A1%E5%B0%94%E7%99%BB1.webp" alt="被轰炸后的凡尔登"><br><img src="/images/%E5%BE%B7%E5%9B%BD420%E6%AF%AB%E7%B1%B3%E9%87%8D%E7%82%AE.webp" alt="德国420毫米重炮"><br><strong>正面进攻</strong><br>3月5日起，德军进攻正面扩大到30公里，并将主突方向转移到默兹河西岸，由急促的冲击改为稳步进攻，企图攻占304高地和265高地，解除西岸法军炮兵的威胁，并从西面包围凡尔登；同时继续加强东岸的攻势，由急促攻击改为稳步进攻，但遭法军顽强抵抗，付出巨大伤亡后仅攻占几个小据点。</p><p>4～5月间，德军集中兵力兵器包括使用喷火器、窒息性毒气和轰炸机，对西岸法军实施重点突击，但步兵进抵304高地和295高地一线后，遭法军炮火猛烈反击，5月底停止进攻。在东岸，法军频繁轮换作战部队，不断实施反击，与德军反复争夺，迟滞德军进攻。</p><p>6月初，德军再次发动大规模攻势，经七天激战切断沃堡与法军其他阵地的联系，迫使沃堡守军于7日投降。6月下旬，德军首次使用光气窒息毒气弹和催泪弹猛攻苏维耶堡，在4公里宽的正面上发射11万发毒气弹，给法军造成重大伤亡，一度进抵距凡尔登不足3公里处，但终被击退。</p><p>24日，法国军队被迫放弃第二道防线，25日德军用强大的火力进攻占领了杜奥蒙要塞。<br>德军由于前进过快，丧失了炮火支援的优势，反而使自己暴露在法军位于默兹河西岸的炮火射程内，战场由于持续炮火的攻击已经变成一片泥潭，火炮很难向前移动，德军最终占领杜奥蒙村时，已经丧失了4个团。<br><img src="/images/%E5%BD%93%E6%97%B6%E5%BD%A2%E5%8A%BF%E5%9B%BE.webp" alt="当时形势图"><br><strong>战役结束</strong><br>由于无法向凡尔登前进，德军转过来准备拿下霍姆山，经过3个月的激烈战斗，德军攻占了凡尔登西部的两个村庄，凡尔登东部的沃要塞投降。但双方损失惨重，贝当将军准备保存实力用于更好的防御，但他被解职，由更具有进攻性的内维尔将军取代。<br>德军下一个目标是苏维要塞，1916年6月22日德军向法军阵地投放毒气弹，第二天以6万兵力进攻，但没有能拿下苏维要塞，战斗持续到9月6日。</p><p>1916年索姆河战役打响，迫使德军从凡尔登抽调部分兵力去对付北面的英法联军。到了秋季，德军已经非常疲惫，德军总司令保罗·冯·兴登堡撤换了法金汉将军，任命埃里希·鲁登道夫为凡尔登战役司令。7月，德军发起了最后一次进攻高潮，但仍被法军抵挡住。</p><p>1916年10月21日法军发起反攻，使用了新式400毫米口径的大炮和徐进弹幕射击技术，10月24日夺回杜奥蒙要塞，11月2日德军放弃沃要塞，12月11日德军完全退到战役开始时的战线。</p><p>俄军1916年夏季进攻战役和西线索姆河战役开始后，德军在凡尔登方向未再投入新的兵力，尔后的进攻行动只是为了牵制当面法军。经数月苦战，德军虽在凡尔登以北、以东地区楔入法军防线7～10公里，但未能达成战役突破。8月29日，法尔肯海恩被免职，兴登堡元帅接任德军总参谋长。9月2日，德皇批准停止进攻。10月24日，法军发起大规模反攻，于11月初收复杜奥蒙堡和沃堡。12月15～18日，法军再次发动反攻，基本收复被德军攻占的阵地。战役至此结束。 在10个月交战中，双方共投入200万兵力，发射了4000万发炮弹，伤亡人数近百万，创造了战争史记录，使凡尔登成了骇人听闻的“绞肉机”和“人间地狱”。</p><h2 id="战役结果"><a href="#战役结果" class="headerlink" title="战役结果"></a>战役结果</h2><p>此役是典型的阵地战、消耗战。双方参战兵力众多、伤亡惨重。法军损失54.3万人，德军损失43.3万人，故此役有“绞肉机”之称。凡尔登战役中组织防御的经验，成为大战后各国修建要塞工事的依据。这次决定性战役是第一次世界大战的转折点，德意志帝国从此逐步走向最后失败。</p><p>虽然法军损失更为严重，但没有达到德军预想的2:1水平。凡尔登虽然使法国到了濒临崩溃的地步，但还没有崩溃，贝当由于坚持战场上的部队必须定期轮换，致使70%的法军都参与了这场战役，而德军只有20%参与了。残酷的战斗造成了心理上的影响，几乎导致法军叛变，由于答应士兵今后再也不参加向德军进攻的严酷的战斗，才使叛变没有真正发生。以后法军士兵拒绝进行进攻性的战斗，只是守在战壕中进行保卫战。其中在凡尔登要塞争夺战，法军一直在要塞碉堡以机枪、迫击炮、强力弹弓（发射手榴弹）对抗来袭的德军。</p><p>战役结束后，德皇威廉二世撤销法金汉的总参谋长职务，改任兴登堡为总参谋长，鲁登道夫为其副手。</p><p>凡尔登战役德法双方投入了近200万兵力，伤亡人数共计达100多万。德军在这一战役中耗尽了元气。法军反攻开始以后，逐次收复了凡尔登以东的大片土地，德军节节败退。<br><img src="/images/%E5%87%A1%E5%B0%94%E7%99%BB%E6%88%98%E5%BD%B9%E5%85%A8%E6%99%AF%E5%9B%BE.webp" alt="凡尔登战役全景图"></p><h2 id="战略意义"><a href="#战略意义" class="headerlink" title="战略意义"></a>战略意义</h2><p>凡尔登战役是第一次世界大战的转折点。德国企图一举击败法国的战略目标再次遭受挫折，损失了巨大的人力和物力，又无法及时弥补。它标志着德国军事进攻的能力已从顶峰跌落，战争主动权逐渐转到协约国手里。到1917年，德、奥阵营日益衰败，终于在1918年战败投降，第一次世界大战随即结束。<br><img src="/images/%E5%87%A1%E5%B0%94%E7%99%BB%E6%88%98%E5%BD%B9%E7%BA%AA%E5%BF%B5%E9%A6%861.webp" alt="凡尔登战役纪念馆1"><br><img src="/images/%E5%87%A1%E5%B0%94%E7%99%BB%E6%88%98%E5%BD%B9%E7%BA%AA%E5%BF%B5%E9%A6%862.webp" alt="凡尔登战役纪念馆2"></p><h2 id="火炮战法"><a href="#火炮战法" class="headerlink" title="火炮战法"></a>火炮战法</h2><p>在这场战役中双方都用了当时的先进武器，比如法国使用了大口径炮巨炮，德军使用了喷火器和毒气弹，对一战有重要影响。这次战役改变了火炮的运用，在此之前火炮多数是用来防守或是在发动进攻前进行一下轰击，而这次德军集中大量火炮运用到进攻中则是火炮的新战法。此次战役中的火炮战法，应该是严格意义上的炮火支援。此后，火炮支援被其他国家效仿，并得到新的发展。在第二次世界大战中，苏军的火炮战法是发展最为成熟的。</p>]]></content>
      
      
      <categories>
          
          <category> History </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日记录</title>
      <link href="//2023/11/05/%E4%BB%8A%E6%97%A5%E8%AE%B0%E5%BD%95/"/>
      <url>//2023/11/05/%E4%BB%8A%E6%97%A5%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h5 id="Ag-Versus-Wolves"><a href="#Ag-Versus-Wolves" class="headerlink" title="Ag Versus Wolves"></a>Ag Versus Wolves</h5><pre><code>Congratulations to Wolves Team.The ninth champion!</code></pre><h5 id="Reading-The-Paper"><a href="#Reading-The-Paper" class="headerlink" title="Reading The Paper"></a>Reading The Paper</h5><pre><code>It is a pity not to post the emoji.I want to say who in the end understands?</code></pre><h5 id="If-you-are-interesting-in-it-please-look-through-it-presumably"><a href="#If-you-are-interesting-in-it-please-look-through-it-presumably" class="headerlink" title="If you are interesting in it,please look through it presumably."></a>If you are interesting in it,please look through it presumably.</h5><p>5.3 Guided Sequence Generation<br>Navigated by the SSTG, we devise heuristics to efficientlyexplore unknownstate space and facilitate comprehensivetraversal. This module outputs the packet pattern sequenceand passes it to the packet instantiationsub-module as a guideline for packet sequence generation.<br>Algorithm 1: Guided packet sequence generation<br>Input: SSTG: System State Tracking Graph<br>Input: PT : transition priority<br>Output: ϕ: packet pattern sequence </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S ← TRAVERSE(SSTG)  </span><br><span class="line">f S is not empty then  </span><br><span class="line">q ← SELECTONE(S)  </span><br><span class="line">ϕ ← ENTERANDAPPEND(SSTG,q)  </span><br><span class="line">else  </span><br><span class="line">ϕ ← ∅  </span><br><span class="line">q ← GETINITIALSTATE(SSTG)  </span><br><span class="line">while HASSUCCESSOR(q) do  </span><br><span class="line">τ ← SELECTTRANSITION(SSTG,PT ,q)  </span><br><span class="line">ϕ ← ϕ∪ GETPACKETPATTERN(τ)  </span><br><span class="line">q ← TRANSITION(SSTG,q, τ)  </span><br><span class="line">return ϕ  </span><br></pre></td></tr></table></figure><p>Algorithm 1 provides an overview of the process: first, weattempt to stress test each SSTG state with diverse inputs by utilizing the proposed mutation operators (Lines 1-4). Specifically, for a SUT State h C(α)|S(β)i ,although the state output α is “deterministic” (the corresponding concrete packets of each execution may vary in some details) such that BLEEM receives the same packet type α as the mutation basis, we can select a different mutation operator σ to construct a different packet pattern α ⊕ σ as test inputs. To this end, we first check whether there is a state q that can be further exercised by other kinds of packet patterns that have not beenapplied (Line 1). If so, we construct a packet pattern sequence ϕ that can reach q and then append the desired packet pattern after ϕ (Line 4). For example, for the SSTG in Figure 6 with Σ 0 &#x3D; {σ◦,σP,σS}, if stressing q1 with a new packet pattern that combines q1’s output b with an unused mutation operator σP, i.e., b⊕σP, then we can construct such a packet pattern sequence: [a ⊕ σ◦,b ⊕ σP]. Second, after all the SUT states have been exercised by all kinds of packet patterns that are available, we attempt to facilitate comprehensive traversal of the implemented SSTG by steering towards low-density regions. We start from the initial state (Line 7) and then run in a loop until reaching an end state (Line 8): in each step, we select the one with the highest priority among the available transitions of the corresponding state (Line 9), record the corresponding packet pattern labeled on it (Line 10), and take this transition (Line 11). It is worth noting that even if we have once applied a packet pattern P to stress a state S and failed to discover new behaviors, it is also worthwhile trying P on S later because, as mentioned above, the set of the packet(s) that P can produce is typically infinite.</p>]]></content>
      
      
      <categories>
          
          <category> Life Record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>普京大帝伟大的一生</title>
      <link href="//2023/10/30/%E6%99%AE%E4%BA%AC%E5%A4%A7%E5%B8%9D/"/>
      <url>//2023/10/30/%E6%99%AE%E4%BA%AC%E5%A4%A7%E5%B8%9D/</url>
      
        <content type="html"><![CDATA[<pre><code>It will be update later.Please look for it.</code></pre>]]></content>
      
      
      <categories>
          
          <category> History </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer network experiment IV</title>
      <link href="//2023/06/25/Computer-network-experiment-IV/"/>
      <url>//2023/06/25/Computer-network-experiment-IV/</url>
      
        <content type="html"><![CDATA[<h3 id="实验任务A"><a href="#实验任务A" class="headerlink" title="实验任务A"></a>实验任务A</h3><p>&ensp;&ensp;&ensp;&ensp;假如你是facebook（meta）公司的一个网络架构师，负责在波士顿郊区建一个机房，服务整个美国东北部的用户，支撑用户发动态、发图、发视频、发评论等功能。现在请你估计机房的大致规模，设计网络结构，并优化L2&#x2F;L3的传输协议。</p><h4 id="1-估算机房大致规模"><a href="#1-估算机房大致规模" class="headerlink" title="1.估算机房大致规模"></a>1.估算机房大致规模</h4><p>**a)用户数量估计:**根据美国东北部地区的人口统计数据和互联网普及率，假设该地区有400万活跃用户。<br>**b)每月消耗数据量估计:**假设每个用户每天平均浏览20条说说（包含动态和发图）和20个视频，每条说说消耗1MB,每个视频消耗20MB。每月按30天计算。则每个用户每月产生的数据量为：(20条说说x1MB+20个视频x10MB)x30天&#x3D;6600MB因此，整个美国东北部地区的用户每月产生的数据量为:400万用户x6600MB&#x3D;25177PB。<br>**c)网络流量估计:**根据用户行为和数据传输需求,假设每个用户每天平均访问Facebook平台30分钟，期间上传和下载数据的平均速率为100Mbps。因此，整个美国东北部地区的用户每天的网络流量为:400w用户x100Mbps&#x3D;400Gbps。</p><h4 id="2-设计网络架构"><a href="#2-设计网络架构" class="headerlink" title="2.设计网络架构"></a>2.设计网络架构</h4><p><strong>a)核心网络：</strong>建议采用分层设计，其中核心网络层负责连接数据中心和用户边缘。在机房内部，可以采用高速交换机构建一个可靠的核心网络，提供高带宽和低延迟的连接。<br><strong>b)边缘网络：</strong>边缘网络层负责连接用户设备和核心网络。可以使用多台路由器和交换机来构建冗余的边缘网络，确保网络可靠性和负载均衡。<br><strong>c)用户接入：</strong>用户接入层通过无线和有线连接提供对用户的接入。建议部署无线接入点（如Wi-Fi）以覆盖机房范围内的用户，并提供有线连接（如光纤）以满足对高速、稳定连接的需求。<br>&ensp;&ensp;&ensp;&ensp;总的来说，采用分布式架构，将不同机房之间通过高速网络连接起来,实现用户数据的分布式存储和传输。可以使用路由器、交换机和光纤等设备来构建高速网络。</p><h4 id="3-优化L2-L3"><a href="#3-优化L2-L3" class="headerlink" title="3.优化L2&#x2F;L3"></a>3.优化L2&#x2F;L3</h4><p><strong>a)L2协议的优化：</strong><br>    链路聚合（Link Aggregation）：将多个物理链路绑定成一个逻辑链路，提高链路带宽和冗余性。这可以通过诸如IEEE 802.3ad（LACP）协议来实现。<br>VLAN划分：使用虚拟局域网（VLAN）来划分网络，实现逻辑隔离和安全性。通过将不同用户、设备或服务隔离到不同的VLAN中，可以减少广播风暴和冲突，提高网络性能和可管理性。<br>    Spanning Tree Protocol (STP) 的优化：STP用于防止网络中的环路，但它可能导致链路冗余时带宽浪费。优化方法包括使用快速收敛的Rapid Spanning Tree Protocol (RSTP) 或者使用基于链路状态的协议，如Multiple Spanning Tree Protocol (MSTP)。<br><strong>b)L3协议的优化：</strong><br>    动态路由协议的优化：选择适当的动态路由协议，如OSPF（Open Shortest Path First）或BGP（Border Gateway Protocol），并进行合理的配置和调优。这包括优化路由更新间隔、调整Hello和Keepalive定时器，以及使用路由汇总和策略路由等技术。<br>负载均衡和流量工程：使用负载均衡技术，如等价路径装载（Equal-Cost Multipath）和流量工程，来平衡流量分布和优化网络利用率。这可以通过配置路由器来实现，根据流量类型、目的地或其他条件进行智能流量调度。<br>QoS（Quality of Service）：通过实施QoS策略，对不同类型的流量进行优先级管理和带宽控制。这可以确保关键应用（如视频传输）具有足够的带宽和低延迟，同时限制非关键流量的影响。<br>    Anycast：通过使用Anycast技术，将相同IP地址分配给位于不同位置的多个服务器，以实现负载均衡和减少延迟。用户的请求将被转发到最近的服务器，提供更快的响应速度。</p><h3 id="实验任务B"><a href="#实验任务B" class="headerlink" title="实验任务B"></a>实验任务B</h3><p>&ensp;&ensp;&ensp;&ensp;假如你是google公司的一个网络架构师，负责欧洲数据中心和美国数据中心之间的数据传输，主要服务搜索业务的需求。数据中心内的网络不用你负责，需要你估计的是欧美之间传输的带宽，并优化长距离大数据量传输的协议。</p><h4 id="1-带宽估计"><a href="#1-带宽估计" class="headerlink" title="1.带宽估计"></a>1.带宽估计</h4><p>   &ensp;&ensp;&ensp;&ensp;欧美之间的数据传输带宽主要依赖于跨大西洋的海底光缆网络。这些海底光缆通过大西洋连接欧洲和美国，承载着跨洋数据传输的主要负载。欧美之间的传输带宽通常是以千兆位（Gbps）或更高的速度进行衡量。其中，MEREA，其长约6600公里，传输速度高达160Tbps。<br>     &ensp;&ensp;&ensp;&ensp;Google曾经自己投资建设专属于自己的光缆网络系统，例如跨大西洋的”Dunant”光缆，以满足其数据传输需求。Dunant 光缆于2020年投入使用，连接了美国弗吉尼亚州和法国法兰西岛之间。该光缆采用了先进的光纤技术，预计提供高达250Tbps的传输能力。  </p><h4 id="2-优化长距离大数据传输的协议"><a href="#2-优化长距离大数据传输的协议" class="headerlink" title="2.优化长距离大数据传输的协议"></a>2.优化长距离大数据传输的协议</h4><p>&ensp;&ensp;&ensp;&ensp;我选择对UDP协议进行优化。TCP协议是一种可靠的协议，但在高延迟和高带宽的网络中，其性能可能会受到限制。因此，我们可以考虑使用UDP协议，它可以提供更高的吞吐量和更低的延迟。但是，UDP协议不是可靠的协议，因此我们需要在应用层实现数据包的确认和重传机制，以确保数据的可靠传输。      <br><strong>1)第一种优化方法：</strong><br>    &ensp;&ensp;&ensp;&ensp;首先将大数据分割成较小的数据包（分片），以适应UDP协议的最大传输单元（MTU）限制。在接收端对接收到的分片进行重组，恢复原始的大数据。然后，实现基于时间戳的流量控制机制，控制数据发送速率，避免过多数据同时发送导致拥塞。并且引入前向纠错机制（Forward Error Correction, FEC），在发送端添加冗余数据，以允许接收端在接收到部分丢失或损坏的数据包时进行纠错。<br>在发送前对数据进行压缩，减少传输数据量。选择适当的压缩算法，权衡压缩率和压缩&#x2F;解压缩开销。因为UDP是不可靠的传输协议，所以需要引入校验和机制，以确保数据的完整性。接收端在接收到数据后验证校验和，如有错误，请求发送端进行重传。<br>&ensp;&ensp;&ensp;&ensp;同时，使用多条路径进行数据传输，通过负载均衡技术将数据分发到多个路径上，提高传输效率和带宽利用率。通过使用数据预加载、预连接或预分配资源等技术，减少传输开始的等待时间，从而减少传输延迟。<br><strong>2)第二种优化方法</strong><br>**a)拥塞控制：  **<br>&ensp;&ensp;&ensp;&ensp;包括速率控制和窗口控制。其中速率控制是主要的，用于调整发送包的周期，基于效率、公平和稳定性的综合考虑获得一个发送周期的初始经验值。当周期内丢包率小于阀值时，下一个周期内发送的包将增长。我们可以使用DAIMD算法。<br>窗口控制是辅助性的，用于动态的限制 NAK 包的数量。速率控制用于快速的达到带宽的最大阀值、快速的丢包恢复及协议内的公平性。窗口控制帮助减少包的丢失和振荡，避免拥塞。这两种机制共同作用保障了传输的高性能和稳定性，提高了效率及公平性。<br><strong>b)带宽估计</strong><br>&ensp;&ensp;&ensp;&ensp;使用对包(PP – Packet pair)的机制来估计 带宽值。即每 16 个包为一组，最后一个是对包，即 发送方不用等到下一个发送周期内再发送。接收方接 收到对包后对其到达时间进行记录，可结合上次记录 的值计算出链路的带宽(计算的方法称为中值过滤法)， 并在下次 ACK 中进行反馈。<br><strong>c)可靠传输</strong><br>&ensp;&ensp;&ensp;&ensp;发送端和接收端都维护一个丢包链表，用于记录 丢包的序号。接收方周期性的发送 ACK 和 NAK 通告 发送方丢包信息。从而实现数据传输的可靠性。根据 拥塞发生严重时丢包是大量连续的特点，使用了较好 的数据压缩机制，一个丢失链表中的节点表示一个丢 包事件，其丢包报告中存放的 32-bit 信息如果首位是 0，则只代表其自身的包丢失，若是 1 则表明从当前 的包序号开始到下一个记录中的所有包都丢失了。例 如：0x00000002, 0x80000006, 0x00000008, 0x0000000B 则表明序号为 2,6,7,8,11 的包都丢失。[1]</p><h3 id="实验任务C"><a href="#实验任务C" class="headerlink" title="实验任务C"></a>实验任务C</h3><p>&ensp;&ensp;&ensp;&ensp;针对（1）和（2）的场景，写出你的分析和协议设计报告，通过代码实现协议，并在能找到的实验场景进行原型实验。例如（1）就可以试试看你在寝室wifi下怎么实现高效的1对多发送，（2）可以试试看在两个寝室之间实现高速传输。</p><h4 id="1-针对任务A："><a href="#1-针对任务A：" class="headerlink" title="1.针对任务A："></a>1.针对任务A：</h4><p>以下是使用优化后的L2&#x2F;L3协议在寝室wife下高效的实现1对多发送代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">multicast_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello, multicast!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多播组地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;multicast_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(multicast_addr));</span><br><span class="line">    multicast_addr.sin_family = AF_INET;</span><br><span class="line">    multicast_addr.sin_addr.s_addr = inet_addr(MULTICAST_GROUP);</span><br><span class="line">    multicast_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字选项，启用多播</span></span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(enable)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;multicast_addr, <span class="keyword">sizeof</span>(multicast_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">multicast_request</span>;</span></span><br><span class="line">    multicast_request.imr_multiaddr.s_addr = inet_addr(MULTICAST_GROUP);</span><br><span class="line">    multicast_request.imr_interface.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="type">char</span> *)&amp;multicast_request, <span class="keyword">sizeof</span>(multicast_request)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;multicast_addr, <span class="keyword">sizeof</span>(multicast_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 间隔1秒发送一次数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-针对任务B"><a href="#2-针对任务B" class="headerlink" title="2.针对任务B:"></a>2.针对任务B:</h4><p>下面是对UDP协议优化后的在两个寝室之间高速传输的主要代码，在WSL2下运行。<br>发送方代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sender</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span> dest_addr_len)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> seq_num = <span class="number">0</span>;</span><br><span class="line">    Packet packet;</span><br><span class="line">    <span class="type">int</span> base = <span class="number">0</span>; <span class="comment">// 窗口的起始位置</span></span><br><span class="line">    <span class="type">int</span> next_seq_num = <span class="number">0</span>; <span class="comment">// 下一个待发送的包的序号</span></span><br><span class="line">    <span class="type">int</span> window_count = <span class="number">0</span>; <span class="comment">// 窗口内包的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送窗口内的包</span></span><br><span class="line">        <span class="keyword">while</span> (window_count &lt; WINDOW_SIZE &amp;&amp; next_seq_num &lt; base + WINDOW_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 构建并发送数据包</span></span><br><span class="line">            packet.seq_num = next_seq_num;</span><br><span class="line">            packet.size = <span class="keyword">sizeof</span>(packet.data);</span><br><span class="line">            <span class="comment">// 在这里填充packet.data的实际数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rand() / (<span class="type">double</span>)RAND_MAX &gt;= LOSS_RATE) &#123;</span><br><span class="line">                <span class="comment">// 模拟丢包</span></span><br><span class="line">                sendto(sockfd, &amp;packet, <span class="keyword">sizeof</span>(packet), <span class="number">0</span>, dest_addr, dest_addr_len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next_seq_num++;</span><br><span class="line">            window_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收ACK/NAK</span></span><br><span class="line">        fd_set fds;</span><br><span class="line">        FD_ZERO(&amp;fds);</span><br><span class="line">        FD_SET(sockfd, &amp;fds);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">        timeout.tv_sec = <span class="number">1</span>; <span class="comment">// 设置超时时间</span></span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (select(sockfd + <span class="number">1</span>, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有可读数据</span></span><br><span class="line">            Packet ack_packet;</span><br><span class="line">            recvfrom(sockfd, &amp;ack_packet, <span class="keyword">sizeof</span>(ack_packet), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ack_packet.seq_num &gt;= base) &#123;</span><br><span class="line">                <span class="comment">// 更新窗口的起始位置和窗口内包的数量</span></span><br><span class="line">                window_count -= ack_packet.seq_num - base + <span class="number">1</span>;</span><br><span class="line">                base = ack_packet.seq_num + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超时，重传窗口内的包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = base; i &lt; base + window_count; i++) &#123;</span><br><span class="line">                packet.seq_num = i;</span><br><span class="line">                packet.size = <span class="keyword">sizeof</span>(packet.data);</span><br><span class="line">                <span class="comment">// 在这里填充packet.data的实际数据</span></span><br><span class="line"></span><br><span class="line">                sendto(sockfd, &amp;packet, <span class="keyword">sizeof</span>(packet), <span class="number">0</span>, dest_addr, dest_addr_len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传输完成</span></span><br><span class="line">        <span class="keyword">if</span> (base &gt;= next_seq_num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收方代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">receiver</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span> src_addr_len)</span> &#123;</span><br><span class="line">    Packet packet;</span><br><span class="line">    <span class="type">uint32_t</span> expected_seq_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据包</span></span><br><span class="line">        recvfrom(sockfd, &amp;packet, <span class="keyword">sizeof</span>(packet), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packet.seq_num == expected_seq_num) &#123;</span><br><span class="line">            <span class="comment">// 发送ACK</span></span><br><span class="line">            sendto(sockfd, &amp;packet, <span class="keyword">sizeof</span>(packet), <span class="number">0</span>, src_addr, src_addr_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数据包</span></span><br><span class="line">            <span class="comment">// 在这里处理接收到的数据包</span></span><br><span class="line"></span><br><span class="line">            expected_seq_num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送NAK</span></span><br><span class="line">            Packet nak_packet;</span><br><span class="line">            nak_packet.seq_num = expected_seq_num - <span class="number">1</span>;</span><br><span class="line">            nak_packet.size = <span class="number">0</span>; <span class="comment">// 表示NAK</span></span><br><span class="line"></span><br><span class="line">            sendto(sockfd, &amp;nak_packet, <span class="keyword">sizeof</span>(nak_packet), <span class="number">0</span>, src_addr, src_addr_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>&ensp;&ensp;&ensp;&ensp;本次实验感觉还是比较难的，有的协议看不太懂，不知道如何优化，在查阅了资料后，找到了类似的优化方法。做的不足的地方还有很多，我根据自己的能力尽可能完成实验，其中还有很多不足的地方需要改进。这是本学期最后一个实验，希望以后能对计算机网络有更深刻的理解和认识。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]张磊,葛敬国,李俊.长距离高带宽环境下UDT协议的分析与应用[J].计算机系统应用,2009,18(10):148-151.<br>[2]Floyd S. High speed TCP for large congestion window. RFC 3646, IETF, Dec 2003<br>[3]<a href="https://blog.csdn.net/guanminwei/article/details/119105557">https://blog.csdn.net/guanminwei/article/details/119105557</a><br>[4]李士宁,王猛,赵磊.长距离高带宽环境下的TCP拥塞控制[J].无线通信技术,2006(01):47-50<br>[5]丁一,汪永琳.长距离高带宽环境下FAST TCP的结构与性能分析[J].科技信息(学术研究),2007(30):1-3</p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小学期日志</title>
      <link href="//2023/06/25/%E5%A4%A7%E4%BA%8C%E5%B0%8F%E5%AD%A6%E6%9C%9F%E8%AE%B0%E5%BD%95/"/>
      <url>//2023/06/25/%E5%A4%A7%E4%BA%8C%E5%B0%8F%E5%AD%A6%E6%9C%9F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h1><h2 id="June-25-Sunday"><a href="#June-25-Sunday" class="headerlink" title="June 25 Sunday"></a>June 25 Sunday</h2><p>&ensp;&ensp;&ensp;&ensp;The rest of the case was tested today. There was a problem with testing the AndrioD-based data acquisition system, and my board could not test the temperature and light curves. Case summary and inspection will be completed tomorrow.</p><h2 id="June-26-Monday"><a href="#June-26-Monday" class="headerlink" title="June 26 Monday"></a>June 26 Monday</h2><p>&ensp;&ensp;&ensp;&ensp;Today, I learned the basic knowledge of bsp programming. Mrs. Ling explained the basic principles and analyzed the basic code. In addition, many people’s 485 bus can not be used, mine is also.</p><h2 id="June-27-Tuesday"><a href="#June-27-Tuesday" class="headerlink" title="June 27 Tuesday"></a>June 27 Tuesday</h2><p>&ensp;&ensp;&ensp;&ensp;Today,we looked through the videos in chaoixng about chapter 5 and chapter 10 .In fact,I fished all the day. In addition,I learned the brush lessons in chaoxing from the Github.Well,that’s all.</p><h2 id="June-28-Wesday"><a href="#June-28-Wesday" class="headerlink" title="June 28 Wesday"></a>June 28 Wesday</h2><p>&ensp;&ensp;&ensp;&ensp;Today,I finished seven projects about stc.I think it is difficult.The Music Project and the “H” project while pressing KEY1 are hard,I turn to others.In addition,the Football Class by selected will be over tomorrow,because there is a test.The form is ask by the teacher and answer by student in site lively.  </p><h2 id="June-30-Friday"><a href="#June-30-Friday" class="headerlink" title="June 30 Friday"></a>June 30 Friday</h2><p>&ensp;&ensp;&ensp;&ensp;Today,we finished the test.The test is easy,because it is similar to previous 10 projects.Certainly,I scored 10 points.Well,many things are left.</p>]]></content>
      
      
      <categories>
          
          <category> Life Record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>History</title>
      <link href="//2023/06/25/%E9%9F%A9%E4%BF%A1%E7%A0%B4%E8%B5%B5%E5%92%8C%E6%A5%9A%E6%B1%89%E4%B9%8B%E4%BA%89/"/>
      <url>//2023/06/25/%E9%9F%A9%E4%BF%A1%E7%A0%B4%E8%B5%B5%E5%92%8C%E6%A5%9A%E6%B1%89%E4%B9%8B%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h3 id="韩信破赵"><a href="#韩信破赵" class="headerlink" title="韩信破赵"></a>韩信破赵</h3><p>&ensp;&ensp;&ensp;&ensp;韩信破赵是楚汉战争中重要一役。楚汉战争之初，楚强汉弱，双方于荥阳、成皋一带相持，汉军经常失利，且腹背受敌，刘邦忧心忡忡。为了扭转被动局面，剪除楚的羽翼赵、代、燕的威胁，刘邦任命韩信为大将带兵北伐代和赵。<br>&ensp;&ensp;&ensp;&ensp;公元前二○五年闰九月，韩信带兵进攻代国，汉军在阏与（今山西和顺）一举打败代军主力，俘获代相夏说，接着韩信与张耳于公元前二○五年十月率兵东向，进攻赵国。赵王歇和陈余闻风，立即集中了军队二十万，在井陉口（今河北井陉境内）安营扎寨，企图阻击汉军东进。<br>&ensp;&ensp;&ensp;&ensp;井陉口地势险要，关隘狭窄，历来是兵家必争之地。赵国谋臣李左车向陈余献计说：“听闻韩信偷渡黄河，俘虏魏王，活捉夏说，血战阏与，如今又有张耳协助，汉军士气旺盛，锐不可当，但汉军也有不利的一面，井陉口隘狭，车子不能并行，骑兵不能成列。汉军要迅速通过几百里狭长的山路，粮食势必落在后头，希望您给我三万精兵，从小路截住汉军辎重，断绝他们的后路，赵军最好深挖壕沟，高筑营垒，坚营固守，不与汉军交锋。这样，他们前进不得，后退不能，不出十日，就可将韩信、张耳的头递到您面前。”<br>&ensp;&ensp;&ensp;&ensp;陈余骄傲自大，自以为熟悉兵书，通晓兵法，对李左车的计策不屑一顾。韩信得知后，非常高兴。<br>&ensp;&ensp;&ensp;&ensp;公元前二○四年十月，韩信带领汉军几万人，加速行军，在距离井陉口三十里的地方驻扎下来，到了半夜，韩信传命汉军准备出发。出发前，他挑选两千骑兵，携带武器和红旗。叫他们从山中小路前进，绕到赵军背后，隐蔽在山沟里，待赵军主力追赶撤退的汉军时，他们再冲出来，拔下赵军旗子，换上汉军红旗，配合主力夹攻赵军。<br>&ensp;&ensp;&ensp;&ensp;经过几个小时行军，在明亮的月色下，汉军进到井陉口，个个精神振奋，跃跃欲试。韩信见赵军已占据了重要地点，准备充分，就命令一万人开出井陉口，背着绵蔓水（井陉东）立阵，赵军见了不知是计，都嘲笑韩信没有军事常识，不会用兵，竟把一万人抛在这个既不能前进又不能撤退的死地方。<br>&ensp;&ensp;&ensp;&ensp;天亮后，韩信命令部下竖起汉军大旗，带着主力军，擂鼓开进井陉口，队伍严整，气势雄壮，早已等得不耐烦的赵军见了，立刻冲出营垒，气势汹汹地杀了过来。双方厮杀激烈，不分胜负。这时，汉军故意丢弃旗鼓，佯装败阵，奔向背水的阵地。会同背水立阵的一万人反击追杀的赵军。赵军见汉军节节败退，以为消灭汉军，活捉韩信和张耳的机会来了，不顾一切地冲杀过来，韩信面对穷追不舍的赵军，微微一笑。汉军因为背水作战，前有二十万赵军的追杀，后有水流湍急的绵蔓水，与其后退淹死在江中，不如向前拼死杀出一条生路，所以汉军将士个个如下山猛虎，英勇杀敌，结果赵军无法取胜。<br>&ensp;&ensp;&ensp;&ensp;当赵军倾巢而出，营垒空虚时，预先埋伏的两千汉骑兵立即乘虚而入，拔掉赵军全部旗帜，换上两千面汉军红旗。当赵军无法取胜准备撤回营垒时，发现自己的营垒上汉军红旗正迎风飘扬，他们大惊失色，以为赵王已被汉军俘虏，顿时军心慌慌，阵脚大乱。于是，汉军两面夹攻，赵军全线溃败，陈余被杀于绵蔓水上，赵王歇成了俘虏。只有受韩信赏识的谋臣李左车受到保护。韩信待之以师长之礼。并向他请教攻伐燕、齐策略。燕、齐迫于汉军声威不得不降。<br>&ensp;&ensp;&ensp;&ensp;韩信出奇制胜，翦除了楚的羽翼，解除了汉军北翼威胁，动摇了楚的后方，对楚形成了一个大包围圈，汉军由被动转为主动。韩信破赵，为楚汉战争的一大转折，为汉刘邦最终消灭楚军奠定了基础。</p><h3 id="楚汉之争"><a href="#楚汉之争" class="headerlink" title="楚汉之争"></a>楚汉之争</h3><p>&ensp;&ensp;&ensp;&ensp;公元前二○七年十一月，项羽率军四十万打进关中，杀死了已经投降的秦王子婴，又放火烧了阿房宫。接着，项羽以胜者自居，自称西楚霸王，并以霸主的身份大封诸侯王。其中刘邦被封为汉王，居汉中、巴蜀之地（今陕西南部及四川一带）。刘邦对项羽自恃强大，违背“先入者为王”的先前之约，甚为不满，但他自知力量不如项羽，只好暂时委曲求全。为了控制刘邦，项羽又特意三分关中，封了三个秦的降将即章邯、司马欣、董翳为王，史称“关中三王”。项羽则东归，定都彭城。但由于项羽分封不公，引起诸侯和功臣的不满，分封不久，握有重兵而未得封王的田荣首先在齐地（今山东临淄地区）起兵，自立为齐王。项羽率兵攻打田荣，刘邦见有机可乘，便乘东方战事再起，项羽忙于平定东方诸侯国叛乱无暇西顾之机，率兵消灭了关中三王，出其不意地重新夺取关中，后又挥兵东下，一举攻下彭城。从此，与项羽展开了长达四年之久的“楚汉战争”。<br>&ensp;&ensp;&ensp;&ensp;项羽听说彭城失陷后，立即班师相救。此时，被胜利冲昏头脑的刘邦失去了警惕，结果，被项羽打得丢盔弃甲，仓皇出逃。项羽俘虏了他的父亲和妻子。刘邦逃到荥阳、成皋一带后，又重整队伍，韩信也带兵前来支援，刘邦渐渐恢复元气。由于东进西击，项羽的力量也渐渐削弱。于是，项羽、刘邦逐渐形成了相持不下的局面。<br>&ensp;&ensp;&ensp;&ensp;其实在这四年战争中，最初项羽的实力强于刘邦，在军事上处于优势地位，但因为他刚愎自用，军纪涣散，到处烧杀掳掠，不得民心。而刘邦则不然，他知人善用，军纪严明，又善于联合各地反项羽力量，以孤立项羽。逐渐地，项羽和刘邦的优势地位发生了转换。眼见刘邦日渐强盛，而自己则因为长期征战，人困马乏，实力渐弱。项羽只好暂时和刘邦讲和，放回其父亲与妻子，约定鸿沟为界，分而治之，互不侵犯。刘邦深知项羽已到了兵疲食尽的地步了，如果划界分而治之，不趁机消灭他，必定养虎遗患。公元前二○三年十二月，刘邦在项羽放回父亲和妻子后，立即撕毁协议，会同各路诸侯对项羽发动了进攻。项羽疏于防范，仓促应战，节节败退，一直退到垓下（今安徽固镇）。一日夜里，项羽在其爱妾虞姬的陪伴下正在军帐中借酒消愁，忽听汉军在四面唱起了楚地民歌，以为汉军已把楚地全部占领了，惊恐不已。于是，项羽挥泪告别以命相殉的虞姬，孤注一掷，连夜率八百名壮士向南突围。天亮时，刘邦发现项羽已逃，连忙派兵追杀，当项羽跑到乌江（今安徽和县东北）时，被汉军追上。两军短兵相接，展开肉搏战。项羽仅剩下的二十八个人也被汉军杀死。穷途末路的项羽奋力拼杀了一阵，面对如此惨状，这位曾经以一夫挡百万之勇的一代枭雄，自感无颜再见江东父老，遂拔剑自刎。历经四年的楚汉之争，最终以农民出身的刘邦的胜利而宣告结束。<br>&ensp;&ensp;&ensp;&ensp;公元前二○二年二月，刘邦即皇帝位，建立西汉王朝，刘邦就是汉高祖。</p>]]></content>
      
      
      <categories>
          
          <category> History </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
